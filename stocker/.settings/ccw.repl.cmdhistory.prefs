cmdhistory=["(defroutes app-routes\\r\\n  (GET \\"/\\" [] \\"asdadasdasdasdasdasd\\"))\\r\\n\\r\\n(def settings (compojure.handler/api app-routes))\\r\\n\\r\\n(run-jetty settings {\:port 3000})" "\\"sdf\\"" "(ns stocker.app-start)\\r\\n\\r\\n(use 'ring.adapter.jetty)\\r\\n(use '[compojure.core])\\r\\n(use '[compojure.handler])\\r\\n\\r\\n(defn rn [] {\:status 200\\r\\n   \:headers {\\"Content-Type\\" \\"text/html\\"}\\r\\n   \:body \\"Hello World\\"})\\r\\n\\r\\n(defroutes app-routes\\r\\n  (GET \\"/\\" [] \\"asdadasdasdasdasdasd\\"))\\r\\n\\r\\n(def settings (compojure.handler/api app-routes))\\r\\n\\r\\n(run-jetty settings {\:port 3000})" "(.stop server)" "(ns stocker.app-start)\\r\\n\\r\\n(use 'ring.adapter.jetty)\\r\\n(use '[compojure.core])\\r\\n(use '[compojure.handler])\\r\\n\\r\\n\\r\\n(defn rn [] {\:status 200\\r\\n   \:headers {\\"Content-Type\\" \\"text/html\\"}\\r\\n   \:body \\"Hello World\\"})\\r\\n\\r\\n(defroutes app-routes\\r\\n  (GET \\"/\\" [] \\"fdc\\"))\\r\\n\\r\\n(def settings (compojure.handler/api app-routes))\\r\\n\\r\\n(defonce server (run-jetty settings {\:port 3000 \:join? false}))" " (keys (first output))" "(def testdata \\r\\n   {\:date \\"2011-9-12\\", \\r\\n    \:url \\"http\://example.com\\", \\r\\n    \:title \\"SQLite Example\\", \\r\\n    \:body \\"Example using SQLite with Clojure\\" \\r\\n    }) \\r\\n \\r\\n \\r\\n (def db \\r\\n   {\:classname   \\"org.sqlite.JDBC\\" \\r\\n    \:subprotocol \\"sqlite\\" \\r\\n    \:subname     \\"db/database.db\\" \\r\\n    }) \\r\\n \\r\\n \\r\\n (defn create-db [] \\r\\n   (try (with-connection db  \\r\\n          (create-table \:news \\r\\n                        [\:date \:text] \\r\\n                        [\:url \:text] \\r\\n                        [\:title \:text] \\r\\n                        [\:body \:text])) \\r\\n        (catch Exception e (println e)))) \\r\\n \\r\\n \\r\\n (create-db)" "(ns db.portfolio-db\\r\\n   (\:use [clojure.java.jdbc])\\r\\n\\r\\n\\r\\n(def testdata \\r\\n   {\:date \\"2011-9-12\\", \\r\\n    \:url \\"http\://example.com\\", \\r\\n    \:title \\"SQLite Example\\", \\r\\n    \:body \\"Example using SQLite with Clojure\\" \\r\\n    }) \\r\\n \\r\\n \\r\\n (def db \\r\\n   {\:classname   \\"org.sqlite.JDBC\\" \\r\\n    \:subprotocol \\"sqlite\\" \\r\\n    \:subname     \\"db/database.db\\" \\r\\n    }) \\r\\n \\r\\n \\r\\n (defn create-db [] \\r\\n   (try (with-connection db  \\r\\n          (create-table \:news \\r\\n                        [\:date \:text] \\r\\n                        [\:url \:text] \\r\\n                        [\:title \:text] \\r\\n                        [\:body \:text])) \\r\\n        (catch Exception e (println e)))) \\r\\n \\r\\n \\r\\n (create-db)" " (def database \\r\\n   {\:classname   \\"org.sqlite.JDBC\\" \\r\\n    \:subprotocol \\"sqlite\\" \\r\\n    \:subname     \\"data/StockER.db\\" \\r\\n    })" " (def output \\r\\n   (with-connection database \\r\\n     (with-query-results rs [\\"select * from Portfolio\\"] (doall rs))))" "(ns clojure-sqlite-example.core \\r\\n   (\:use [clojure.java.jdbc])) \\r\\n \\r\\n \\r\\n (def database \\r\\n   {\:classname   \\"org.sqlite.JDBC\\" \\r\\n    \:subprotocol \\"sqlite\\" \\r\\n    \:subname     \\"data/StockER.db\\" \\r\\n    }) \\r\\n \\r\\n\\r\\n (def output \\r\\n   (with-connection database \\r\\n     (with-query-results rs [\\"select * from Portfolio\\"] (doall rs)))) \\r\\n\\r\\n \\r\\n (keys (first output))" " (def database \\r\\n   {\:classname   \\"org.sqlite.JDBC\\" \\r\\n    \:subprotocol \\"sqlite\\" \\r\\n    \:subname     \\"data/StockER.db\\" \\r\\n    })" " (def output \\r\\n   (with-connection database \\r\\n     (with-query-results rs [\\"select * from Portfolio\\"] (doall rs))))" "(use '[clojure.java.jdbc])" "(def output \\r\\n   (with-connection database \\r\\n     (with-query-results rs [\\"select * from Portfolio\\"] (doall rs))))" "(def database \\r\\n   {\:classname   \\"org.sqlite.JDBC\\" \\r\\n    \:subprotocol \\"sqlite\\" \\r\\n    \:subname     \\"data/StockER.db\\" \\r\\n    }) \\r\\n \\r\\n\\r\\n (def output \\r\\n   (with-connection database \\r\\n     (with-query-results rs [\\"select * from Portfolio\\"] (doall rs))))" " (keys (first output))" "(ns db.portfolio-db\\r\\n (\:use [clojure.java.jdbc])\\r\\n\\r\\n (def database \\r\\n   {\:classname   \\"org.sqlite.JDBC\\" \\r\\n    \:subprotocol \\"sqlite\\" \\r\\n    \:subname     \\"data/StockER.db\\" \\r\\n    }) \\r\\n \\r\\n\\r\\n (def output \\r\\n   (with-connection database \\r\\n     (with-query-results rs [\\"select * from Portfolio\\"] (doall rs)))) \\r\\n\\r\\n \\r\\n (keys (first output))" "(ns db.portfolio-db\\r\\n (\:use [clojure.java.jdbc])" "(ns portfolio-db\\r\\n (\:use [clojure.java.jdbc])" "(ns portfoliodb\\r\\n (\:use [clojure.java.jdbc])" "(ns clojure-sqlite-example.core \\r\\n  (\:use [clojure.java.jdbc]))" "(ns portfolio-db\\r\\n (\:require [clojure.java.jdbc])" "(def database \\r\\n   {\:classname   \\"org.sqlite.JDBC\\" \\r\\n    \:subprotocol \\"sqlite\\" \\r\\n    \:subname     \\"data/StockER.db\\" \\r\\n    }) \\r\\n \\r\\n\\r\\n (def output \\r\\n   (with-connection database \\r\\n     (with-query-results rs [\\"select * from Portfolio\\"] (doall rs)))) \\r\\n\\r\\n \\r\\n (keys (first output))" "  (def database \\r\\n    {\:classname   \\"org.sqlite.JDBC\\" \\r\\n    \:subprotocol \\"sqlite\\" \\r\\n    \:subname     \\"data/StockER.db\\" \\r\\n    }) \\r\\n \\r\\n  (def output \\r\\n    (with-connection database \\r\\n      (with-query-results rs [\\"select * from Portfolio\\"] (doall rs)))) \\r\\n  \\r\\n \\r\\n  (keys (first output))" "(use [clojure.java.jdbc])\\r\\n  (def database \\r\\n    {\:classname   \\"org.sqlite.JDBC\\" \\r\\n    \:subprotocol \\"sqlite\\" \\r\\n    \:subname     \\"data/StockER.db\\" \\r\\n    }) \\r\\n \\r\\n  (def output \\r\\n    (with-connection database \\r\\n      (with-query-results rs [\\"select * from Portfolio\\"] (doall rs)))) \\r\\n  \\r\\n \\r\\n  (keys (first output))" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] (doall rs)))) \\r\\n \\r\\n(get-portfolio-by-id 0)" "(get-portfolio-by-id 1)" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] (first rs))))" "(get-portfolio-by-id 1)" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let portfolio (first rs) \\r\\n        (extend (first portfolio)  {\:Stocks \\r\\n                                    ((with-query-results rs [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id] ))}))))" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let portfolio (first rs) \\r\\n        (extend (first portfolio)  {\:Stocks \\r\\n                                    (with-query-results rs [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id] )}))))" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let portfolio (first rs)))))" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      )))" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let [portfolio (first rs)]))))" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let [portfolio (first rs)] \\r\\n        (extend (first portfolio)  {\:Stocks \\r\\n                                    (with-query-results rs [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id] )}))))" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let [portfolio (first rs)] \\r\\n        (extend (first portfolio)  {\:Stocks \\"asd\\"})))))" "(get-portfolio-by-id 1)" " \\r\\n(extend java.lang.Number \\r\\n\\r\\n  Dateable \\r\\n\\r\\n  {\:to-ms identity})" "(expand {\:a 1} {\:b 2})" "(assoc  {\:a 1} {\:b 2})" "(assoc  {\:a 1} \:b 2)" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let [portfolio (first rs)] \\r\\n        (assoc (first portfolio)  \:Stocks \\r\\n                                 (with-query-results rs [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id] )))))" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let [portfolio (first rs)] \\r\\n        (first portfolio)))))" "(get-portfolio-by-id 1)" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let [portfolio  rs] \\r\\n        (first portfolio)))))" "(get-portfolio-by-id 1)" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let [portfolio  rs] \\r\\n        (assoc portfolio \:Stocks {})))))" "(get-portfolio-by-id 1)" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let [portfolio  rs] \\r\\n        (into {} portfolio \:Stocks {})))))" "(get-portfolio-by-id 1)" "(merge {A\:\\"\\"} {B\:\\"\\"})" "(merge {A\:} {B\:1})" "(union {A\:} {B\:1})" "(concat {A\:} {B\:1})" "(concat {A\:1} {B\:1})" "(println {A\:1} {B\:1})" "(println {\:A 2} {\:B 1})" "(union {\:A 2} {\:B 1})" "(concat {\:A 2} {\:B 1})" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let [portfolio  rs] \\r\\n        (assoc  {\:Stocks } (first portfolio))))))" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let [portfolio  rs] \\r\\n        (assoc  {\:Stocks 1} (first portfolio))))))" "(get-portfolio-by-id 1)" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let [portfolio  rs] \\r\\n        (assoc (first portfolio)  \:Stocks 1)))))" "(get-portfolio-by-id 1)" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let [portfolio  rs] \\r\\n        (assoc (first portfolio)  \\r\\n               \:Stocks (with-query-results rs [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id]  (doall rs))))))" "(defn get-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n      (let [portfolio  rs] \\r\\n        (assoc (first portfolio)  \\r\\n               \:Stocks (with-query-results rs \\n                         [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id]  \\n                         (doall rs)))))))" "(get-portfolio-by-id 1)" "(defn get-stock-starts-top [value take] \\r\\n  (with-connection database \\r\\n       (with-query-results rs [\\"select * from Stock where Id \= ? limit ?\\" (\\"%\\" + value) take] ((doall rs)))))\\n(get-stock-starts-top \\"M\\" 10)" "(\\"%\\" + \\"M\\")" "(clojure.string/join [\\"a\\" \\"b\\" \\"c\\"])" "(get-stock-starts-top \\"M\\" 10)" "(clojure.string/join [\\"%\\" value])" "((fn [value] (clojure.string/join [\\"%\\" value])) \\"a\\")" "(defn get-stock-starts-top [value take] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Stock where Id \= ? limit ?\\" (clojure.string/join [\\"%\\" \\"lj\\"]) take] ((doall rs)))))" "(get-stock-starts-top \\"M\\" 10)" "(defn get-stock-starts-top [value take] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Stock where Id \= ?\\" (clojure.string/join [\\"%\\" value])] ((doall rs)))))" "(get-stock-starts-top \\"M\\" 1)" "(def database \\r\\n  {\:classname   \\"org.sqlite.JDBC\\" \\r\\n   \:subprotocol \\"sqlite\\" \\r\\n   \:subname     \\"data/StockER.db\\"})" "(defn get-stock-by-id [id] \\r\\n  (with-connection database \\r\\n       (with-query-results rs [\\"select * from Stock where Id \= ?\\" id] rs)))" "(get-stock-by-id \\"MSFT\\")" "(defn get-stock-starts-top [value] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Stock where Id \= ?\\" (clojure.string/join [\\"%\\" value])] ((doall rs)))))" "(get-stock-starts-top \\"M\\")" "(defn get-stock-starts-top [value] \\r\\n  (with-connection database \\r\\n    (with-query-results rs \\n      [\\"select * from Stock where Id \= ?\\" \\n       (clojure.string/join [\\"%\\" value])] \\n         (doall rs))))" "(get-stock-starts-top \\"M\\")" "(defn get-stock-starts-top [value] \\r\\n  (with-connection database \\r\\n    (with-query-results rs \\n      [\\"select * from Stock where Id \= ?\\" \\n       (clojure.string/join [value \\"%\\"])] \\n         (doall rs))))" "(get-stock-starts-top \\"M\\")" "(defn get-stock-starts-top [value] \\r\\n  (with-connection database \\r\\n    (with-query-results rs \\n      [\\"select * from Stock where Id like ?\\" \\n       (clojure.string/join [value \\"%\\"])] \\n         (doall rs))))" "(get-stock-starts-top \\"M\\")" "(defn get-stock-starts-top [value take] \\r\\n  (with-connection database \\r\\n    (with-query-results rs \\n      [\\"select * from Stock where Id like ? limit ?\\" \\n       (clojure.string/join [value \\"%\\"]) take] \\n         (doall rs))))" "(get-stock-starts-top \\"M\\" 5)" "(defn stock? [id] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Stock where Id \= ?\\" id]\\n      (rs \=\= nil))))" "(stock? \\"MSFT\\")" "(defn stock? [id] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Stock where Id \= ?\\" id] \\r\\n      (nil rs))))" "(defn stock? [id] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Stock where Id \= ?\\" id] \\r\\n      (nil? rs))))" "(stock? \\"MSFT\\")" "(stock? \\"MSFTasdasdasd\\")" "(defn stock? [id] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Stock where Id \= ?\\" id] \\r\\n      (not \\r\\n        (nil rs)))))" "(defn stock? [id] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Stock where Id \= ?\\" id] \\r\\n      (not \\r\\n        (nil? rs)))))" "(stock? \\"MSFTasdasdasd\\")" "(stock? \\"MSFT\\")" "(ns stocker.app-start\\r\\n  (\:use \\r\\n    [compojure.core]  \\r\\n    [ring.middleware.resource]\\r\\n    [ring.adapter.jetty]\\r\\n    [controller.stockcontroller])\\r\\n  (\:require  \\r\\n \\t  [compojure.route \:as route] \\r\\n \\t  [compojure.handler \:as handler])) \\r\\n\\r\\n(defroutes resources-routes      \\r\\n  (route/resources \\"/\\") \\r\\n  (route/not-found \\"<h1>Page not found</h1>\\")) \\r\\n\\r\\n \\r\\n(def app   \\r\\n  ((handler/site stock-actions)\\r\\n    (handler/site resources-routes))) \\r\\n\\r\\n\\r\\n(defonce server (run-jetty app {\:port 3000 \:join? false}))" "((println \\"A\\") (println \\"A\\") )" "(-> (println \\"A\\") (println \\"A\\") )" "(ns stocker.app-start\\r\\n  (\:use \\r\\n    [compojure.core]   \\r\\n    [ring.middleware.resource]\\r\\n    [ring.adapter.jetty]\\r\\n   )\\r\\n  (\:require  \\r\\n \\t  [compojure.route \:as route] \\r\\n \\t  [compojure.handler \:as handler]\\r\\n    [controller.stockcontroller \:as stock])) \\r\\n\\r\\n(stock/get-by-id \\"MSFT\\")" "(ns stocker.app-start\\r\\n  (\:use \\r\\n    [compojure.core]   \\r\\n    [ring.middleware.resource]\\r\\n    [ring.adapter.jetty]\\r\\n   )\\r\\n  (\:require  \\r\\n \\t  [compojure.route \:as route] \\r\\n \\t  [compojure.handler \:as handler]\\r\\n    [controller.stockcontroller \:as stock]))" "(get-by-id \\"MSFT\\")" "(ns controller.stockcontroller\\r\\n  (\:use [compojure.core] [db.stock-db \:as db]))\\r\\n\\r\\n(defn get-by-id [id] (db/get-stock-by-id  id))" "get-by-id" "(get-by-id \\"lkj\\")" "(get-by-id \\"MSFT\\")" "(defroutes app-routes\\r\\n  (GET \\"/\\" [] \\"\:\:\:\:\:\:\:\:\:\\")\\r\\n\\r\\n  (GET \\"/Stock/\:id\\" [id] (\:Name (stock/get-by-id id)))\\r\\n\\r\\n  (route/resources \\"/\\") \\r\\n  (route/not-found \\"<h1>Page not found</h1>\\")) \\r\\n\\r\\n \\r\\n(def app   \\r\\n  (handler/site app-routes))" "(ns controller.stockcontroller\\r\\n  (\:use [compojure.core] [db.stock-db \:as db]))\\r\\n\\r\\n(defn get-by-id [id] (db/get-stock-by-id  id))" "(ns controller.stockcontroller\\r\\n  (\:use [compojure.core] [db.stock-db \:as database]))\\r\\n\\r\\n(defn get-by-id [id] (database/get-stock-by-id  id))" "(ns controller.stockcontroller\\r\\n  (\:require [compojure.core] [db.stock-db \:as database]))\\r\\n\\r\\n(defn get-by-id [id] (database/get-stock-by-id  id))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as database]))\\r\\n\\r\\n(defn get-by-id [id] (database/get-stock-by-id  id))" "(ns controller.stockcontroller\\r\\n  (\:use [db.stock-db \:as database]))\\r\\n\\r\\n(defn get-by-id [id] (database/get-stock-by-id  id))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn get-by-id [id] (database/get-stock-by-id  id))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn get-by-id [id] (db/get-stock-by-id  id))" "(get-by-id \\"MSFT\\")" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn get-by-id [id] (db/get-stock-by-id  id))" "(get-by-id \\"MSFT\\")" "(def stop (.stop server))" "(stop)" "(.stop server)" "(defn  build-responce  [func,type,params] \\r\\n  ;;(try \\r\\n    (type (func params) 200) )" "(build-responce stock/get-by-id json-responce {\:id \\"MSFT\\"})" "(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n         (let [portfolio  rs] \\r\\n           (assoc (models/portfolio (first portfolio))  \\r\\n                  \:Stocks (with-query-results rs \\r\\n                            [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id]  \\r\\n                            (doall (map rs models/stock))))))))" "(get-portfolio-by-id 1)" "(ns db.portfolio-db\\r\\n  (\:use \\r\\n    [clojure.java.jdbc \:exclude [resultset-seq]]\\r\\n    [db.database]\\r\\n    [model.transport-map \:as models])) \\r\\n\\r\\n \\r\\n(defn get-portfolios [] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio\\"] (doall (map rs models/portfolio))))) \\r\\n  \\r\\n(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n         (let [portfolio  rs] \\r\\n           (assoc (models/portfolio (first portfolio))  \\r\\n                  \:Stocks (with-query-results rs \\r\\n                            [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id]  \\r\\n                            (doall (map rs models/stock))))))))" "(get-portfolio-by-id 1)" "(get-portfolio-by-id 0)" "(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n         (let [portfolio  rs] \\r\\n           (assoc (models/portfolio (first portfolio))  \\r\\n                  \:Stocks (with-query-results rs \\r\\n                            [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id]  \\r\\n                            (doall  rs )))))))" "(get-portfolio-by-id 0)" "(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n         (let [portfolio  rs] \\r\\n           (assoc (first portfolio)  \\r\\n                  \:Stocks (with-query-results rs \\r\\n                            [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id]  \\r\\n                            (doall  rs )))))))" "(get-portfolio-by-id 0)" "(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n         (let [portfolio  (first (doall (rs)))] \\r\\n           (assoc portfolio  \\r\\n                  \:Stocks (with-query-results rs \\r\\n                            [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id]  \\r\\n                            (doall  rs )))))))" "(get-portfolio-by-id 0)" "(get-portfolio-by-id 1)" "(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n         (let [portfolio  rs] \\r\\n           (assoc (first portfolio)  \\r\\n                  \:Stocks (with-query-results rs \\r\\n                            [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id]  \\r\\n                            (doall  rs )))))))" "(get-portfolio-by-id 1)" "(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n         (let [portfolio  rs] \\r\\n           (assoc (models/portfolio (first portfolio))  \\r\\n                  \:Stocks (with-query-results rs \\r\\n                            [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id]  \\r\\n                            (doall (map models/stock rs))))))))" "(get-portfolio-by-id 1)" "(ns db.stock-db\\r\\n  (\:use \\r\\n    [clojure.java.jdbc \:exclude [resultset-seq]]\\r\\n    [db.database]\\r\\n    [model.transport-map \:as models]))\\r\\n\\r\\n(defn get-stock-by-id [id] \\r\\n  (with-connection database \\r\\n       (with-query-results rs [\\"select * from Stock where Id \= ?\\" id]   (models/stock (first (doall rs))))))\\r\\n\\r\\n(defn get-stock-starts-top [value take] \\r\\n     (with-connection database \\r\\n       (with-query-results rs \\r\\n         [\\"select * from Stock where Id like ? limit ?\\" \\r\\n          (clojure.string/join [value \\"%\\"]) take] \\r\\n            (doall (map rs (models/stock ))))))\\r\\n\\r\\n(defn stock? [id] \\r\\n  (not \\r\\n    (nil? \\r\\n      (get-stock-by-id id))))" "(stick? \\"MSFT\\")" "(stock? \\"MSFT\\")" "(stock? \\"MST\\")" "(stock? \\"MSTkl\\")" "(defn stock? [id] \\r\\n  (not \\r\\n    (nil? \\r\\n      (\:id(get-stock-by-id id)))))" "(stock? \\"MSTkl\\")" "(stock? \\"MST\\")" "(stock? \\"MSFT\\")" "(defn stock? [id] \\r\\n  (not \\r\\n    (nil? \\r\\n      (\:id (get-stock-by-id id)))))" "(stock? \\"MSFT\\")" "(defn stock? [id] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Stock where Id \= ?\\" id] \\r\\n      (not \\r\\n        (nil? rs)))))" "(stock? \\"MSFT\\")" "(stock? \\"MST\\")" "(stock? \\"MSTkl\\")" "(get-stock-starts-top \\"M\\" 5)" "(ns db.stock-db\\r\\n  (\:use \\r\\n    [clojure.java.jdbc \:exclude [resultset-seq]]\\r\\n    [db.database]\\r\\n    [model.transport-map \:as models]))\\r\\n\\r\\n(defn get-stock-by-id [id] \\r\\n  (with-connection database \\r\\n       (with-query-results rs [\\"select * from Stock where Id \= ?\\" id]   \\r\\n         (models/stock (first (doall rs))))))\\r\\n\\r\\n(defn get-stock-starts-top [value take] \\r\\n     (with-connection database \\r\\n       (with-query-results rs \\r\\n         [\\"select * from Stock where Id like ? limit ?\\" \\r\\n          (clojure.string/join [value \\"%\\"]) take] \\r\\n            (doall (map rs (models/stock ))))))\\r\\n\\r\\n(defn stock? [id] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Stock where Id \= ?\\" id] \\r\\n      (not \\r\\n        (nil? rs)))))" "(get-stock-starts-top \\"M\\" 5)" "(ns db.stock-db\\r\\n  (\:use \\r\\n    [clojure.java.jdbc \:exclude [resultset-seq]]\\r\\n    [db.database]\\r\\n    [model.transport-map \:as models]))\\r\\n\\r\\n(defn get-stock-by-id [id] \\r\\n  (with-connection database \\r\\n       (with-query-results rs [\\"select * from Stock where Id \= ?\\" id]   \\r\\n         (models/stock (first (doall rs))))))\\r\\n\\r\\n(defn get-stock-starts-top [value take] \\r\\n     (with-connection database \\r\\n       (with-query-results rs \\r\\n         [\\"select * from Stock where Id like ? limit ?\\" \\r\\n          (clojure.string/join [value \\"%\\"]) take] \\r\\n            (doall (map (models/stock ) rs)))))\\r\\n\\r\\n(defn stock? [id] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Stock where Id \= ?\\" id] \\r\\n      (not \\r\\n        (nil? rs)))))" "(get-stock-starts-top \\"M\\" 5)" "(defn get-stock-starts-top [value take] \\r\\n     (with-connection database \\r\\n       (with-query-results rs \\r\\n         [\\"select * from Stock where Id like ? limit ?\\" \\r\\n          (clojure.string/join [value \\"%\\"]) take] \\r\\n            (doall (map rs models/stock)))))" "(get-stock-starts-top \\"M\\" 5)" "(defn get-stock-starts-top [value take] \\r\\n     (with-connection database \\r\\n       (with-query-results rs \\r\\n         [\\"select * from Stock where Id like ? limit ?\\" \\r\\n          (clojure.string/join [value \\"%\\"]) take] \\r\\n            (doall (map  models/stock rs)))))" "(get-stock-starts-top \\"M\\" 5)" "(defn get-stock-by-id [id] \\r\\n  (with-connection database \\r\\n       (with-query-results rs [\\"select * from Stock where Id \= ?\\" id]   \\r\\n         (models/stock (first (doall rs))))))\\r\\n\\r\\n(defn get-stock-starts-top [value take] \\r\\n     (with-connection database \\r\\n       (with-query-results rs \\r\\n         [\\"select * from Stock where Id like ? limit ?\\" \\r\\n          (clojure.string/join [value \\"%\\"]) take] \\r\\n            (doall (map  models/stock rs)))))\\r\\n\\r\\n(defn stock? [id] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Stock where Id \= ?\\" id] \\r\\n      (not \\r\\n        (nil? rs)))))" "(ns db.stock-db\\r\\n  (\:use \\r\\n    [clojure.java.jdbc \:exclude [resultset-seq]]\\r\\n    [db.database]\\r\\n    [model.transport-map \:as models]))\\r\\n\\r\\n(defn get-stock-by-id [id] \\r\\n  (with-connection database \\r\\n       (with-query-results rs [\\"select * from Stock where Id \= ?\\" id]   \\r\\n         (models/stock (first (doall rs))))))\\r\\n\\r\\n(defn get-stock-starts-top [value take] \\r\\n     (with-connection database \\r\\n       (with-query-results rs \\r\\n         [\\"select * from Stock where Id like ? limit ?\\" \\r\\n          (clojure.string/join [value \\"%\\"]) take] \\r\\n            (doall (map  models/stock rs)))))\\r\\n\\r\\n(defn stock? [id] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Stock where Id \= ?\\" id] \\r\\n      (not \\r\\n        (nil? rs)))))" "(get-stock-starts-top \\"M\\" 5\\n                      )" "\\n\\n(stock/get-stock-starts-top {\:value \\"M\\" take\:5})" "\\n\\n(stock/get-stock-starts-top {\:value \\"M\\" \:take \\n                             5})" "\\n\\n(stock/get-stock-starts-top {\:value \\"M\\" \:take 5})" "{\:value \\"M\\" \:take 5}" "\\n\\n(stock/get-stock-starts-top {\:value \\"M\\" \:take 5})" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn get-by-id [params] \\r\\n  (db/get-stock-by-id  \\r\\n    (\:id params)))\\r\\n\\r\\n(defn get-stock-starts-top  [params] \\r\\n    (db/get-stock-starts-top\\r\\n      (do (println (\:value params))) (\:take params)))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (db/stock?\\r\\n      (\:name params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn get-by-id [params] \\r\\n  (db/get-stock-by-id  \\r\\n    (\:id params)))\\r\\n\\r\\n(defn get-stock-starts-top  [params] \\r\\n    (db/get-stock-starts-top\\r\\n      (println (\:value params)) (\:take params)))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (db/stock?\\r\\n      (\:name params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn get-stock-starts-top  [params] \\r\\n    (println \\"asdasdasdasd\\"))" "(defn get-stock-starts-top  [params] \\r\\n    (println params))" "(get-stock-starts {\:Ads \\"asd\\"}\\n                  )" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn get-by-id [params] \\r\\n  (db/get-stock-by-id  \\r\\n    (\:id params)))\\r\\n\\r\\n(defn get-stock-starts-top  [params]    \\r\\n  (db/get-stock-starts-top\\r\\n     (\:value params) (\:take params)))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (db/stock?\\r\\n     (println (\:name params))))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn get-by-id [params] \\r\\n  (db/get-stock-by-id  \\r\\n    (\:id params)))\\r\\n\\r\\n(defn get-stock-starts-top  [params]    \\r\\n  (db/get-stock-starts-top\\r\\n     (\:value params) (\:take params)))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (db/stock?\\r\\n     (println  params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn get-by-id [params] \\r\\n  (db/get-stock-by-id  \\r\\n    (\:id params)))\\r\\n\\r\\n(defn get-stock-starts-top  [params]    \\r\\n  (db/get-stock-starts-top\\r\\n     (\:value params) (\:take params)))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (db/stock? (\:name params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn get-by-id [params] \\r\\n  (db/get-stock-by-id  \\r\\n    (\:id params)))\\r\\n\\r\\n(defn get-stock-starts-top  [params]    \\r\\n  (db/get-stock-starts-top\\r\\n     (\:value params) (\:take params)))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (db/stock? (println (\:name params))))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (db/stock? (println (\:name params))))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println (\:name params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println (keys params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println (params \:name)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println (\:name params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println (name params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println  (first params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println  (\:name (first params))))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println  (\:name params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println  params))" "{\:name \\"KL\\"}" "(\:n {\:n \\"lk\\"})" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println  (\:value params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println  ( params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println  params))" "(println {\:m \\"m\\"})" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println  {\:m \\"m\\"}))" "{\\"Name\\" \\"NMJ\\"}" "{Name \\"NMJ\\"}" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println (\:name params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println params))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (get name params))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println (get name params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println (get \\"name\\" params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println (get name params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println (type params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println (reduce (fn [a p] (println p) ) params)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println (get params name)))" "(ns controller.stockcontroller\\r\\n  (\:require [db.stock-db \:as db]))\\r\\n\\r\\n(defn stock?  [params] \\r\\n    (println (get params \\"name\\")))" "(ns db.stock-db\\r\\n  (\:use \\r\\n    [clojure.java.jdbc \:exclude [resultset-seq]]\\r\\n    [db.database]\\r\\n    [model.transport-map \:as models]))\\r\\n\\r\\n(defn get-stock-by-id [id] \\r\\n  (with-connection database \\r\\n       (with-query-results rs [\\"select * from Stock where Id \= ?\\" id]   \\r\\n         (models/stock (first (doall rs))))))\\r\\n\\r\\n(defn get-stock-starts-top [value take] \\r\\n     (with-connection database \\r\\n       (with-query-results rs \\r\\n         [\\"select * from Stock where Id like ? limit ?\\" \\r\\n          (clojure.string/join [value \\"%\\"]) take] \\r\\n            (doall (map  models/stock rs)))))\\r\\n\\r\\n(defn stock? [id] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Stock where Id \= ?\\" id] \\r\\n      (not \\r\\n        (nil? (first rs))))))" "(defn validate-portfolio [portfolio] \\r\\n (and \\r\\n   (\:Id portfolio)\\r\\n   (\:Name portfolio)))" "(ns model.transport-map\\r\\n  \:use [clojure.core])\\r\\n\\r\\n(defn stock [values] \\r\\n  { \:Id (\:id values) \\r\\n    \:StockExchange (\:stockexchange values)\\r\\n    \:Name (\:name values)\\r\\n    \:IPOyear (\:ipoyear values)\\r\\n    \:Sector (\:sector values)\\r\\n    \:Industry (\:industry values)\\r\\n    \:SummaryQuote (\:summaryquote values)}) \\r\\n\\r\\n(defn portfolio [values] \\r\\n  { \:Id  (\:id values) \\r\\n    \:Name (\:name values)\\r\\n    \:Icon (\:icon values)})" "(defn get-all [params] \\r\\n    (db/get-portfolios))" "(ns controller.portfolio\\r\\n  (\:require [db.portfolio-db \:as db]\\r\\n            [model.transport-map \:as models]))\\r\\n\\r\\n(defn get-all [params] \\r\\n    (db/get-portfolios))" "(get-all)" "(get-all {})" "(ns controller.portfolio\\r\\n  (\:require [db.portfolio-db \:as db]\\r\\n            [model.transport-map \:as models]))\\r\\n\\r\\n(defn get-all [params] \\r\\n    (db/get-portfolios))\\r\\n\\r\\n(defn get-by-id [params]   \\r\\n  (db/get-portfolio-by-id  \\r\\n      (\:id params)))" "(get-by-id 7)" "(get-by-id 1)" "(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs \\n         [\\"select * from Portfolio where Id \= ?\\" id])))" "(ns db.portfolio-db\\r\\n  (\:use \\r\\n    [clojure.java.jdbc \:exclude [resultset-seq]]\\r\\n    [db.database]\\r\\n    [model.transport-map \:as models])) \\n(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs \\n         [\\"select * from Portfolio where Id \= ?\\" id])))" "(get-portfolio-by-id 7)" "(ns db.portfolio-db\\r\\n  (\:use \\r\\n    [clojure.java.jdbc \:exclude [resultset-seq]]\\r\\n    [db.database]\\r\\n    [model.transport-map \:as models])) \\n(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs \\n         [\\"select * from Portfolio where Id \= ?\\" id] rs)))" "(get-portfolio-by-id 7)" "(ns db.portfolio-db\\r\\n  (\:use \\r\\n    [clojure.java.jdbc \:exclude [resultset-seq]]\\r\\n    [db.database]\\r\\n    [model.transport-map \:as models])) \\n(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs \\n         [\\"select * from Portfolio where Id \= ?\\" id] rs)))" "(get-portfolio-by-id 7)" "(ns db.portfolio-db\\r\\n  (\:use \\r\\n    [clojure.java.jdbc \:exclude [resultset-seq]]\\r\\n    [db.database]\\r\\n    [model.transport-map \:as models])) \\r\\n\\r\\n \\r\\n(defn get-portfolios [] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio\\"] (doall (map models/portfolio rs))))) \\r\\n  \\r\\n(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n         (let [portfolio  rs] \\r\\n           (assoc (models/portfolio (first portfolio))  \\r\\n                  \:Stocks (with-query-results rs \\r\\n                            [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id]  \\r\\n                            (doall (map models/stock rs))))))))\\r\\n\\r\\n(defn add-portfolio [portfolio]\\r\\n  (with-connection database \\r\\n    (second (first (insert-record \:Portfolio portfolio)))))\\r\\n\\r\\n(defn remove-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (delete-rows [\\"delete from Portfolio where Id \= ?\\" id]))) \\r\\n  \\r\\n(defn add-stock-to-portfolio [portfilioId,stockId]\\r\\n  (with-connection database \\r\\n    (insert-record \:PortfolioStock {\:PortfolioId portfilioId \:StockId (\:Id stockId)}))) \\r\\n\\r\\n(defn remove-stock-from-portfolio [portfilioId,stockId]\\r\\n  (with-connection database \\r\\n   (delete-rows [\\"delete from PortfolioStock where PortfolioId \= ? and StockId \= ?\\" portfilioId stockId])))" "(get-portfolio-by-id 7)" "(get-portfolio-by-id 1)" "(ns db.portfolio-db\\r\\n  (\:use \\r\\n    [clojure.java.jdbc \:exclude [resultset-seq]]\\r\\n    [db.database]\\r\\n    [model.transport-map \:as models])) \\r\\n\\r\\n \\r\\n(defn get-portfolios [] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio\\"] (doall (map models/portfolio rs))))) \\r\\n  \\r\\n(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n         (let [portfolio  rs] \\r\\n           (assoc (models/portfolio (first portfolio))  \\r\\n                  \:Stocks (with-query-results rs \\r\\n                            [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id]  \\r\\n                            (doall (map models/stock rs))))))))\\r\\n\\r\\n(defn add-portfolio [portfolio]\\r\\n  (with-connection database \\r\\n    (second (first (insert-record \:Portfolio portfolio)))))\\r\\n\\r\\n(defn remove-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (delete-rows [\\"delete from Portfolio where Id \= ?\\" id]))) \\r\\n  \\r\\n(defn add-stock-to-portfolio [portfilioId,stockId]\\r\\n  (with-connection database \\r\\n    (insert-record \:PortfolioStock {\:PortfolioId portfilioId \:StockId (\:Id stockId)}))) \\r\\n\\r\\n(defn remove-stock-from-portfolio [portfilioId,stockId]\\r\\n  (with-connection database \\r\\n   (delete-rows [\\"delete from PortfolioStock where PortfolioId \= ? and StockId \= ?\\" portfilioId stockId])))" "(remove-portfolio-by-id 7)" "(ns db.portfolio-db\\r\\n  (\:use \\r\\n    [clojure.java.jdbc \:exclude [resultset-seq]]\\r\\n    [db.database]\\r\\n    [model.transport-map \:as models])) \\r\\n\\r\\n \\r\\n(defn get-portfolios [] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio\\"] (doall (map models/portfolio rs))))) \\r\\n  \\r\\n(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n         (let [portfolio  rs] \\r\\n           (assoc (models/portfolio (first portfolio))  \\r\\n                  \:Stocks (with-query-results rs \\r\\n                            [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id]  \\r\\n                            (doall (map models/stock rs))))))))\\r\\n\\r\\n(defn add-portfolio [portfolio]\\r\\n  (with-connection database \\r\\n    (second (first (insert-record \:Portfolio portfolio)))))\\r\\n\\r\\n(defn remove-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (delete-rows \:Portfolio {\:id id}))) \\r\\n  \\r\\n(defn add-stock-to-portfolio [portfilioId,stockId]\\r\\n  (with-connection database \\r\\n    (insert-record \:PortfolioStock {\:PortfolioId portfilioId \:StockId (\:Id stockId)}))) \\r\\n\\r\\n(defn remove-stock-from-portfolio [portfilioId,stockId]\\r\\n  (with-connection database \\r\\n   (delete-rows [\\"delete from PortfolioStock where PortfolioId \= ? and StockId \= ?\\" portfilioId stockId])))" "(remove-portfolio-by-id 7)" "(ns db.portfolio-db\\r\\n  (\:use \\r\\n    [clojure.java.jdbc \:exclude [resultset-seq]]\\r\\n    [db.database]\\r\\n    [model.transport-map \:as models])) \\r\\n\\r\\n \\r\\n(defn get-portfolios [] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio\\"] (doall (map models/portfolio rs))))) \\r\\n  \\r\\n(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n         (let [portfolio  rs] \\r\\n           (assoc (models/portfolio (first portfolio))  \\r\\n                  \:Stocks (with-query-results rs \\r\\n                            [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id]  \\r\\n                            (doall (map models/stock rs))))))))\\r\\n\\r\\n(defn add-portfolio [portfolio]\\r\\n  (with-connection database \\r\\n    (second (first (insert-record \:Portfolio portfolio)))))\\r\\n\\r\\n(defn remove-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (delete-rows \:Portfolio [\\"id\=?\\"] [id]))) \\r\\n  \\r\\n(defn add-stock-to-portfolio [portfilioId,stockId]\\r\\n  (with-connection database \\r\\n    (insert-record \:PortfolioStock {\:PortfolioId portfilioId \:StockId (\:Id stockId)}))) \\r\\n\\r\\n(defn remove-stock-from-portfolio [portfilioId,stockId]\\r\\n  (with-connection database \\r\\n   (delete-rows [\\"delete from PortfolioStock where PortfolioId \= ? and StockId \= ?\\" portfilioId stockId])))" "(remove-portfolio-by-id 7)" "(ns db.portfolio-db\\r\\n  (\:use \\r\\n    [clojure.java.jdbc \:exclude [resultset-seq]]\\r\\n    [db.database]\\r\\n    [model.transport-map \:as models])) \\r\\n\\r\\n \\r\\n(defn get-portfolios [] \\r\\n  (with-connection database \\r\\n    (with-query-results rs [\\"select * from Portfolio\\"] (doall (map models/portfolio rs))))) \\r\\n  \\r\\n(defn get-portfolio-by-id [id]\\r\\n     (with-connection database \\r\\n       (with-query-results rs [\\"select * from Portfolio where Id \= ?\\" id] \\r\\n         (let [portfolio  rs] \\r\\n           (assoc (models/portfolio (first portfolio))  \\r\\n                  \:Stocks (with-query-results rs \\r\\n                            [\\"select s.* from PortfolioStock ps inner join Stock s on(s.Id \= ps.StockId)  where ps.PortfolioId \= ?\\" id]  \\r\\n                            (doall (map models/stock rs))))))))\\r\\n\\r\\n(defn add-portfolio [portfolio]\\r\\n  (with-connection database \\r\\n    (second (first (insert-record \:Portfolio portfolio)))))\\r\\n\\r\\n(defn remove-portfolio-by-id [id]\\r\\n  (with-connection database \\r\\n    (delete-rows \:Portfolio [\\"id\=?\\" id]))) \\r\\n  \\r\\n(defn add-stock-to-portfolio [portfilioId,stockId]\\r\\n  (with-connection database \\r\\n    (insert-record \:PortfolioStock {\:PortfolioId portfilioId \:StockId (\:Id stockId)}))) \\r\\n\\r\\n(defn remove-stock-from-portfolio [portfilioId,stockId]\\r\\n  (with-connection database \\r\\n   (delete-rows [\\"delete from PortfolioStock where PortfolioId \= ? and StockId \= ?\\" portfilioId stockId])))" "(remove-portfolio-by-id 7)" "(def [[1 1 1]\\n      [1 1 1]\\n      [1 1 1]])" "(def m1 [[1 1 1]\\n         [1 1 1]\\n         [1 1 1]])" "(let [i 0 j 0]\\n  (set\! i i+1))" "(println (let [i 0 j 0]\\n           (set\! i i+1)))" "(prinln \\"asd\\")" "(do \\"\\")" "(do \\n (let [x 1]\\n   (+ x 1)))" "(do \\n (let [x 1]\\n   (set x 5\\n        x)))" "(def m1 [[1 1 1]\\n         [1 1 1]\\n         [1 1 1]])" "(reduce (fn [a r] (+ a r)) m1)" "(reduce (fn [a r] (+ a 1)) m1)" "(reduce (fn [a r] (+ a 1)) m1 0)" "(map (fn [a r] (+ a 1)) m1)" "(for [i (range 3)] [i])" "(for [i (range 3)] i)" "(for [i (count m1)] i)" "m1" "(count m1)" "(for [i m1] i)" "(for [i m1] \\n  (fn [i] i))" "(for [i m1 j (first m1)] [i j])" "(def m1 [[1 2 3]\\n         [4 5 6]\\n         [7 8 9]])" "(for [i m1 j (first m1)] [i j])" "(for \\n  [i (range (count m1)) \\n   j (range (count(first m1)))] \\n  [i j])" "\\r\\n(reduce \\r\\n         (fn [primes number] primes) m1)" "\\r\\n(reduce (fn [primes number] n) m1)" "\\r\\n(reduce (fn [primes number] number) m1)" "\\r\\n(reduce (fn [primes number a] a) m1)" "\\r\\n(reduce (fn [a row] row) m1)" "\\r\\n(use 'clojure.core.matrix)" "(def test [[1 2 3]\\r\\n           [4 5 6]\\r\\n           [7 8 9]])" "(def M1 [[1 2 3]\\r\\n         [4 5 6]\\r\\n         [7 8 9]])" "(+ M1 M1)" "(defn calculate \\r\\n  \\"Array multiply operator. Uses elementwise multiplication.\\" \\r\\n  ([a] a) \\r\\n  ([a b] \\r\\n    (calculate a b)) \\r\\n  ([a b & more] \\r\\n    (reduce calculate (calculate a b) more))) \\r\\n\\r\\n\\r\\n(def M1 [[1 2 3]\\r\\n         [4 5 6]\\r\\n         [7 8 9]])" "(+ M1 M1)" "((fn [a b] (* a b))  M1 M1)" "((fn [a b] (+ (* a b) 5))  M1 M1)" "(\\n  euclidean-distance  M1 M1)" "(euclidean-distance 5 4)" "(euclidean-distance 10 4)" "(+ M1 M1)" "(euclidean-distance M1 M1)" "(\\n  (fn [a b] \\n    (println (str a b)))  M1 M1)" "(\\n  (fn [a b] \\n    (println (str a)))  M1 M1)" "(\\n  (fn [a b] \\n    (do \\n      (println  a)\\n      (println  b)))  M1 M1)" "(+ [[1 2 3] [4 5 6] [7 8 9]] [[1 2 3] [4 5 6] [7 8 9]])" "(defn calculate \\r\\n  \\"Array multiply operator. Uses elementwise multiplication.\\" \\r\\n  ([f a] a) \\r\\n  ([f a b] \\r\\n    (f a b)) \\r\\n  ([f a b & more] \\r\\n    (reduce calculate (f a b) more))) \\r\\n\\r\\n(defn pow \\r\\n  ([m] \\r\\n    m) \\r\\n   ([m exponent] \\r\\n    (mp/element-pow m exponent)) \\r\\n   ([m exponent & more] \\r\\n     (reduce (fn [m x] (mp/element-pow m x)) (mp/element-pow m exponent) more))) \\r\\n\\r\\n\\r\\n\\r\\n(def M1 [[1 2 3]\\r\\n         [4 5 6]\\r\\n         [7 8 9]])" "(calculate euclidean-distance M1 M2)" "\\r\\n(def M1 [[1 2 3]\\r\\n         [4 5 6]\\r\\n         [7 8 9]])" "(calculate euclidean-distance M1 M2)" "(calculate euclidean-distance M1 M1)" "\\r\\n(loop [x 10] \\r\\n\\r\\n  (when (> x 1) \\r\\n\\r\\n    (println x) \\r\\n\\r\\n    (recur (- x 2))))" "(for [x (range 3)] x)" "(ereduce + M1)" "(ns utils.nmf\\r\\n (\:use [utils.cost-functions \:as cf]\\r\\n       [clojure.core.matrix.operators \:as m]))" "(ereduce + M1)" "(ereduce + M1 M1)" "(def my-atom (atom 0))" "(swap\! my-atom inc)" "(defn- calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)]\\r\\n (for [x (range (first m1)) y (range (first m1))] \\r\\n   y )))" "(calculate euclidean-distance M1 M2)" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)]\\r\\n dim))\\n   ;;(for [x (range (first m1)) y (range (first m1))] \\r\\n   ;;y )))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)]\\r\\n (for [x (range (first m1)) ]\\r\\n   (for [y (range (first m1))] \\r\\n   y )))" "(defn- calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)]\\r\\n (for [x (range (first m1)) ]\\r\\n   (for [y (range (first m1))] \\r\\n   y ))))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)]\\r\\n (for [x (range (first dim)) y (range (second dim))] \\r\\n   x)))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)]\\r\\n (for [x (range (first dim)) y (range (second dim))] \\r\\n   (swap\! aggr (+ aggr x)))))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)]\\r\\n (for [x (range (first dim)) y (range (second dim))] \\r\\n   (swap\! aggr (fn [a] (+ a x))))))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n    (let  i (atom 0)\\n          j (atom 0)]\\r\\n   (reduce \\n     (fn [aggr row] \\n       (swap\! i inc)\\n       (reduce \\n         (fn [aggr column] \\n           (swap\! j inc)\\n           j)\\n         )) M1)))" "(defn- calculate [f m1 m2]\\r\\n    (let  [i (atom 0)\\n          j (atom 0)]\\r\\n   (reduce \\n     (fn [aggr row] \\n       (swap\! i inc)\\n       (reduce \\n         (fn [aggr column] \\n           (swap\! j inc)\\n           j)\\n         )) M1)))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n    (let  [i (atom 0)\\n          j (atom 0)]\\r\\n   (reduce \\n     (fn [aggr row] \\n       (swap\! i inc)\\n       (reduce \\n         (fn [aggr column] \\n           (swap\! j inc)\\n           j)\\n         )row) m1)))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n    (let  [i (atom 0)\\n          j (atom 0)]\\r\\n   (reduce \\n     (fn [aggr row] \\n       (swap\! i inc)\\n       (reduce \\n         (fn [aggr column] \\n           (swap\! j inc)\\n           j)\\n         row)) m1)))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n    (let  [i (atom 0)\\n          j (atom 0)]\\r\\n   (reduce \\n     (fn [aggr row] \\n       (swap\! i inc)\\n       (reduce \\n         (fn [aggr column] \\n           (swap\! j inc)\\n           @j)\\n         row)) m1)))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n    (let  [i (atom 0)\\n          j (atom 0)]\\r\\n   (reduce \\n     (fn [aggr row] \\n       (swap\! i inc)\\n       (reduce \\n         (fn [aggr column] \\n           (swap\! j inc)\\n           (+ column (m @x @j))\\n         row)) m1))))" "(defn- calculate [f m1 m2]\\r\\n    (let  [i (atom 0)\\n          j (atom 0)]\\r\\n   (reduce \\n     (fn [aggr row] \\n       (swap\! i inc)\\n       (reduce \\n         (fn [aggr column] \\n           (swap\! j inc)\\n           (+ column (m2 @x @j))\\n         row)) m1))))" "(defn- calculate [f m1 m2]\\r\\n    (let  [i (atom 0)\\n          j (atom 0)]\\r\\n   (reduce \\n     (fn [aggr row] \\n       (swap\! i inc)\\n       (reduce \\n         (fn [aggr column] \\n           (swap\! j inc)\\n           (+ column (m2 @i @j))\\n         row)) m1))))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n    (let  [i (atom 0)\\n          j (atom 0)]\\r\\n   (reduce \\n     (fn [aggr row] \\n       (swap\! i inc)\\n       (reduce \\n         (fn [aggr column] \\n           (swap\! j inc)\\n           (+ column (m2 @i @j))\\n         )row)) m1)))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n    (let  [i (atom 0)\\n          j (atom 0)]\\r\\n   (reduce \\n     (fn [aggr row] \\n       (swap\! i inc)\\n       (reduce \\n         (fn [aggr column] \\n           (swap\! j inc)\\n           (+ column (mget m2 @i @j))\\n         )row)) m1)))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n    (let  [i (atom -1)\\n          j (atom -1)]\\r\\n   (reduce \\n     (fn [aggr row] \\n       (swap\! i inc)\\n       (reduce \\n         (fn [aggr column] \\n           (swap\! j inc)\\n           (+ column (mget m2 @i @j))\\n         )row)) m1)))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n    (let  [i (atom -1)\\n          j (atom -1)]\\r\\n   (reduce \\n     (fn [aggr row] \\n       (swap\! i inc)\\n       (reduce \\n         (fn [aggr column] \\n           (swap\! j inc)\\n           (+ column (mget m2 0 0))\\n         )row)) m1)))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n    (let  [i (atom -1)\\n          j (atom -1)]\\r\\n   (reduce \\n     (fn [aggr row] \\n       (swap\! i inc)\\n       (reduce \\n         (fn [aggr column] \\n           (swap\! j inc)\\n           [@i @j])\\n         )row)) m1))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n    (let  [i (atom -1)\\n          j (atom -1)]\\r\\n   (reduce \\n     (fn [aggr row] \\n       (swap\! i inc)\\n       (reduce \\n         (fn [aggr column] \\n           (swap\! j inc)\\n           [@i @j])\\n         row) )m1)))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)]\\r\\n (for [x (range (first dim)) y (range (second dim))] \\r\\n   (+ (mget m1 i j) (mget m2 i j)))))" "(defn- calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)]\\r\\n (for [x (range (first dim)) j (range (second dim))] \\r\\n   (+ (mget m1 i j) (mget m2 i j)))))" "(defn- calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)]\\r\\n (for [i (range (first dim)) j (range (second dim))] \\r\\n   (+ (mget m1 i j) (mget m2 i j)))))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)]\\r\\n (for [i (range (first dim)) j (range (second dim))] \\r\\n   (f (mget m1 i j) (mget m2 i j)))))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)\\r\\n       ff (for [x (range (first dim)) y (range (second dim))] \\r\\n            (+ (mget m1 i j) (mget m2 i j)))]\\r\\n   (sum ff)))" "(defn- calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (+ (mget m1 i j) (mget m2 i j)))]\\r\\n   (sum ff)))" "(defn- calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (+ (mget m1 i j) (mget m2 i j)))]\\r\\n   (reduce + ff)))" "(calculate euclidean-distance M1 M1)" "(defn- calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (mget m1 i j) (mget m2 i j)))]\\r\\n   (reduce + ff)))" "(calculate euclidean-distance M1 M1)" "(def m1 [[1 2 3]\\n         [1 2 3]\\n         [1 2 3]])" "(def m1 [[3 2 1]\\n         [3 2 1]\\n         [3 2 1]])" "(def m2 [[1 2 3]\\n         [1 2 3]\\n         [1 2 3]])" "(calculate euclidean-distance m1 m2)" "(defn-\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n  calculate [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (mget m1 i j) (mget m2 i j)))]\\r\\n   (reduce + ff)))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (mget m1 i j) (mget m2 i j)))]\\r\\n   (reduce + ff)))" "(java.utils.random 5)" "(def r (java.util.Random. 1))" "(r)" "(java.util.Random.)" "@(java.util.Random.)" "@(java.util.Random. 1)" "(defn- random matrix [i j]\\r\\n [i j] \\r\\n  (let [element-count (* i j) \\r\\n        randoms (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)] \\r\\n    (matrix randoms columns)))" "(defn- random matrix [i j]\\r\\n [i j] \\r\\n  (let [element-count (* i j) \\r\\n        randoms (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)] \\r\\n    (matrix randoms j)))" "(defn- random matrix [i j]\\r\\n  (let [element-count (* i j) \\r\\n        randoms (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)] \\r\\n    (matrix randoms j)))" " (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)" " (stats/sample-uniform \\n   10 \:min Double/MIN_VALUE \:max 2\\n   )" "(defn- random matrix [i j]\\r\\n  (let [element-count (* i j) \\r\\n        randoms (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)] \\r\\n    (matrix randoms j)))" "(* [[1 2]\\n    [3 4]] [[4 3]\\n            [2 1]])" "(ns utils.nmf\\r\\n  (\:use [utils.cost-functions \:as cf])\\r\\n  (\:require [incanter.core \:as incanter] \\r\\n            [incanter.stats \:as stats]))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim (shape m1)\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (mget m1 i j) (mget m2 i j)))]\\r\\n   (reduce + ff)))" "(matrix [1 2 3])" "(ns utils.nmf\\r\\n  (\:use [utils.cost-functions \:as cf]\\r\\n        [incanter.core \:only [matrix sel nrow ncol mmult trans]])\\r\\n  (\:require [incanter.core \:as incanter] \\r\\n            [incanter.stats \:as stats])\\r\\n  (\:import [cern.colt.matrix.tdouble DoubleMatrix2D]))" "(matrix [1 2 3] 1)" "(defn- random matrix [i j]\\r\\n  (let [element-count (* i j) \\r\\n        randoms (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)] \\r\\n    (matrix randoms j)))" "(defn- random matrix [i j]\\r\\n  (let [element-count (* i j) \\r\\n        randoms \\n        (stats/sample-uniform element-count \\n                              \:min Double/MIN_VALUE \\n                              \:max 2)] \\r\\n    (matrix randoms j)))" "(stats/sample-uniform 4 \\r\\n                                 \:min Double/MIN_VALUE \\r\\n                                 \:max 2)" "(defn- random matrix [i j]\\r\\n  (let [element-count (* i j) \\r\\n        randoms (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)] \\n    randoms))" "(defn- random-matrix [i j]\\r\\n  (let [element-count (* i j) \\r\\n        randoms (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)] \\n    randoms))" "(defn- random-matrix [i j]\\r\\n  (let [element-count (* i j) \\r\\n        randoms (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)] \\r\\n    (matrix randoms j)))" "(matrix [[1 2 3]\\r\\n         [4 5 6]\\r\\n         [7 8 9]])" "(defn- random-matrix\\r\\n  \\"Generates a random matrix size ixj  \\r\\n[1 ... i]\\r\\n...\\r\\n[j ... i]\\"\\r\\n  [i j]\\r\\n  (let [element-count (* i j) \\r\\n        randoms (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)] \\r\\n    (matrix randoms j)))" "(matrix [1 2 3 4 5 6 7 8 9] 3)" "(first (matrix [1 2 3 4 5 6 7 8 9] 3))" " (let [aggr (atom 0) \\r\\n       dim  [(count (first m1)) (count m1)]\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (mget m1 i j) (mget m2 i j)))]\\r\\n   (reduce + ff)))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [(count (first m1)) (count m1)]\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (mget m1 i j) (mget m2 i j)))]\\r\\n   (reduce + ff)))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [(count (first m1)) (count m1)]\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (get (get m1 i) j) (get (get m1 i) j)))]\\r\\n   (reduce + ff)))" "(def M1 [[1 2 3]\\r\\n         [4 5 6]\\r\\n         [7 8 9]])" "( calculate + M1 M2)" "( calculate + M1 M1)" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" "(random-matrix 10 10)" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [((- count (first m1))) (- (count m)1)]\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (get (get m1 i) j) (get (get m1 i) j)))]\\r\\n   (reduce + ff)))\\r\\n\\r\\n(defn- random-matrix\\r\\n  \\"Generates a random matrix size ixj  \\r\\n[1 ... i]\\r\\n...\\r\\n[j ... i]\\"\\r\\n  [i j]\\r\\n  (let [element-count (* i j) \\r\\n        randoms (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)] \\r\\n    (matrix randoms j)))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [((- count (first m1))) (- (count m1)1)]\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (get (get m1 i) j) (get (get m1 i) j)))]\\r\\n   (reduce + ff)))\\r\\n\\r\\n(defn- random-matrix\\r\\n  \\"Generates a random matrix size ixj  \\r\\n[1 ... i]\\r\\n...\\r\\n[j ... i]\\"\\r\\n  [i j]\\r\\n  (let [element-count (* i j) \\r\\n        randoms (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)] \\r\\n    (matrix randoms j)))" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" " (- (count M1) 1)" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [(- (count (first m1))) (- (count m1) 1)]\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (get (get m1 i) j) (get (get m1 i) j)))]\\r\\n   (reduce + ff)))" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [(- (count (first m1))) (- (count m1) 1)]\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (get (get m1 i) j) (get (get m1 i) j)))]\\r\\n   ff))" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [(- (count (first m1))) (- (count m1) 1)]\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (get (get m1 i) j) (get (get m1 i) j)))]\\r\\n   dim))" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [(- (count (first m1)) 1) (- (count m1) 1)]\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (get (get m1 i) j) (get (get m1 i) j)))]\\r\\n   (reduce + ff)))" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [(- (count (first m1))) (- (count m1) 1)]\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (get (get m1 i) j) (get (get m1 i) j)))]\\r\\n   dim))" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [(- (count (first m1)) 1) (- (count m1) 1)]\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (get (get m1 i) j) (get (get m1 i) j)))]\\r\\n   dim))" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [(- (count (first m1)) 1) (- (count m1) 1)]\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (get (get m1 i) j))]\\r\\n   dim))" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [(- (count (first m1)) 1) (- (count m1) 1)]\\r\\n       ff (for [i (range (first dim)) \\n                j (range (second dim))] \\r\\n            i)]\\r\\n   dim))" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [(- (count (first m1)) 1) (- (count m1) 1)]\\r\\n       ff (for [i (range (first dim)) \\n                ] \\r\\n            i)]\\r\\n   dim))" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [(- (count (first m1)) 1) (- (count m1) 1)]\\r\\n       ff (for [i (range (first dim)) \\n                j (range (second dim))] \\r\\n            i)]\\r\\n   ff))" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [(- (count (first m1)) 1) (- (count m1) 1)]\\r\\n       ff (for [i (range (first dim)) \\n                j (range (second dim))] \\r\\n            (get (get m1 i) j))]\\r\\n   ff))" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [(- (count (first m1)) 1) (- (count m1) 1)]\\r\\n       ff (for [i (range (first dim)) \\n                j (range (second dim))] \\r\\n            get m1 i)]\\r\\n   ff))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [(- (count (first m1)) 1) (- (count m1) 1)]\\r\\n       ff (for [i (range (first dim)) \\n                j (range (second dim))] \\r\\n            (get m1 i))]\\r\\n   ff))" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" "(get (random-matrix 10 10) 5)" "(random-matrix 10 10)" "(def  a (random-matrix 10 10))" "(a)" "a" "(get a 2)" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [ (count (first m1))  (count m1)]\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (sel  m1 i j) ( m2 i j)))]\\r\\n   (reduce + ff)))" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" ";;NOTE  needs improvement\\r\\n(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [ (count (first m1))  (count m1)]\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (sel  m1 i j) (sel m2 i j)))]\\r\\n   (reduce + ff)))" "(calculate euclidean-distance (random-matrix 10 10) (random-matrix 10 10))" "(calculate euclidean-distance \\n           (random-matrix 10000 10000) \\n           (random-matrix 10000 10000))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(calculate euclidean-distance \\n           (random-matrix 10000 1000) \\n           (random-matrix 10000 1000))" "(calculate euclidean-distance \\n           (random-matrix 10000 100) \\n           (random-matrix 10000 100))" "(calculate euclidean-distance \\n           (random-matrix 1000 100) \\n           (random-matrix 1000 100))" "(random-matrix 1000 100)" "(calculate euclidean-distance \\n           (random-matrix 1000 100) \\n           (random-matrix 1000 100))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(calculate euclidean-distance \\n           (random-matrix 2 3) \\n           (random-matrix 2 3))" "(calculate euclidean-distance \\n           (random-matrix 20 3) \\n           (random-matrix 20 3))" "(calculate euclidean-distance \\n           (random-matrix 4 3) \\n           (random-matrix 4 3))" "find-cost" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [aggr (atom 0) \\r\\n       dim  [ (nrow m1)  (ncol m1)]\\r\\n       ff (for [i (range (first dim)) j (range (second dim))] \\r\\n            (f (sel  m1 i j) (sel m2 i j)))]\\r\\n   (reduce + 0 ff)))\\r\\n\\r\\n(defn- random-matrix\\r\\n  \\"Generates a random matrix size ixj  \\r\\n[(1 1) ... (i 1)]\\r\\n...\\r\\n[(1 j) ... (i j)]\\"\\r\\n  [i j]\\r\\n  (let [element-count (* i j) \\r\\n        randoms (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)] \\r\\n    (matrix randoms j)))" "(calculate euclidean-distance \\n           (random-matrix 4 3) \\n           (random-matrix 4 3))" "(calculate euclidean-distance \\n           (random-matrix 4 6) \\n           (random-matrix 4 6))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(calculate euclidean-distance \\n           (random-matrix 10000 1000) \\n           (random-matrix 10000 1000))" ";;NOTE  needs improvement\\r\\n(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       ff (for [i (range  nrow m1) j (range (ncol m1))] \\r\\n            (f (sel  m1 i j) (sel m2 i j)))]\\r\\n   (reduce + 0 ff)))\\r\\n\\r\\n(defn- random-matrix\\r\\n  \\"Generates a random matrix size ixj  \\r\\n[(1 1) ... (i 1)]\\r\\n...\\r\\n[(1 j) ... (i j)]\\"\\r\\n  [i j]\\r\\n  (let [element-count (* i j) \\r\\n        randoms (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)] \\r\\n    (matrix randoms j)))" "(calculate euclidean-distance \\n           (random-matrix 10000 1000) \\n           (random-matrix 10000 1000))" "(calculate euclidean-distance \\n           (random-matrix 100 100) \\n           (random-matrix 100 100))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (f (sel  m1 i j) (sel m2 i j)))]\\r\\n   (reduce + 0 ff)))" "(calculate euclidean-distance \\n           (random-matrix 100 100) \\n           (random-matrix 100 100))" "(calculate euclidean-distance \\n           (random-matrix 10000 1000) \\n           (random-matrix 10000 1000))" "(matrix-of [1 2 3] 1)" "(definline euclidean-distance \\"returns (x+y)^2\\"  [^double x ^double y] \\r\\n  (let [dis (- x y)] \\r\\n    (* dis dis)))" "(definline euclidean-distance \\"returns (x+y)^2\\"  [^double x ^double y] \\r\\n  '(let [dis (- x y)] \\r\\n     (* dis dis)))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" ";;NOTE  needs improvement\\r\\n(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       aggr (red 0)  \\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (ref-set aggr + (f (sel  m1 i j) (sel m2 i j))))]\\r\\n   @aggr))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       aggr (ref 0)  \\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (ref-set aggr + (f (sel  m1 i j) (sel m2 i j))))]\\r\\n   @aggr))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" ";;NOTE  needs improvement\\r\\n(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n      \\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (f (sel  m1 i j) (sel m2 i j)))]\\r\\n   (reduce + 0 ff)))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (atom 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (swap\! a + (f (sel  m1 i j) (sel m2 i j))))]\\r\\n   a)" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (atom 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (swap\! a + (f (sel  m1 i j) (sel m2 i j))))]\\r\\n   a))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (atom 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (swap\! a + (f (sel  m1 i j) (sel m2 i j))))]\\r\\n   @a))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(ref a 0)" "(ref 0)" "@(ref 0)" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (ref 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (set-ref a + (f (sel  m1 i j) (sel m2 i j))))]\\r\\n   @a))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (ref 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (ref-set a + (f (sel  m1 i j) (sel m2 i j))))]\\r\\n   @a))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (ref 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            @(ref-set a + (f (sel  m1 i j) (sel m2 i j))))]\\r\\n   ff))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (ref 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            @(ref-set a (+ @a (f (sel  m1 i j) (sel m2 i j)))))]\\r\\n   @a))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (ref 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            @(ref-set a (+ @a (f (sel  m1 i j) (sel m2 i j)))))]\\r\\n   ff))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (ref 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (ref-set a (+ @a (f (sel  m1 i j) (sel m2 i j)))))]\\r\\n   ff))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (atom 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (swop\! a (+ @a (f (sel  m1 i j) (sel m2 i j)))))]\\r\\n   ff))" ";NOTE  needs improvement\\r\\n(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (atom 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (swop\! a +  (f (sel  m1 i j) (sel m2 i j))))]\\r\\n   ff))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (atom 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (swap\!\! a +  (f (sel  m1 i j) (sel m2 i j))))]\\r\\n   ff))" ";;NOTE  needs improvement\\r\\n(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (atom 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (swap\! a +  (f (sel  m1 i j) (sel m2 i j))))]\\r\\n   ff))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(calculate euclidean-distance \\n           (random-matrix 3 3) \\n           (random-matrix 3 3))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (atom 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (swap\! a +  (f (sel  m1 i j) (sel m2 i j))))]\\r\\n   @(do ff)))" "(calculate euclidean-distance \\n           (random-matrix 3 3) \\n           (random-matrix 3 3))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (atom 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (swap\! a +  (f (sel  m1 i j) (sel m2 i j))))]\\r\\n   @ff))" "(calculate euclidean-distance \\n           (random-matrix 3 3) \\n           (random-matrix 3 3))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (atom 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (swap\! a +  (f (sel  m1 i j) (sel m2 i j))))]\\r\\n   @(do a)))" "(calculate euclidean-distance \\n           (random-matrix 3 3) \\n           (random-matrix 3 3))" "(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (atom 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (swap\! a +  (f (sel  m1 i j) (sel m2 i j))))]\\r\\n    (do ff)))" "(calculate euclidean-distance \\n           (random-matrix 3 3) \\n           (random-matrix 3 3))" ";;NOTE  needs improvement\\r\\n(defn- calculate\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (atom 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (swap\! a +  (f (sel  m1 i j) (sel m2 i j))))]\\r\\n    (last ff)))" "(calculate euclidean-distance \\n           (random-matrix 3 3) \\n           (random-matrix 3 3))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(calculate euclidean-distance \\n           (random-matrix 1000 10000) \\n           (random-matrix 1000 10000))" "(defn- sum [ & args] \\r\\n  (apply reduce + 0 args)) \\r\\n\\r\\n\\r\\n(defn- cost-of-approximation \\r\\n   \\"by-part-cost is a function of two numbers that should \\r\\n    return a cost, decreasing the two numbers approach one another\\" \\r\\n   [cost-function M W H] \\r\\n   (let [costs-by-part \\r\\n         (for [i (range (nrow M)) j (range (ncol M))] \\r\\n           (let [M-i-j (sel M i j) \\r\\n                 WH-i-j (item-in-product i j W H)] \\r\\n             (cost-function M-i-j WH-i-j)))] \\r\\n     (sum costs-by-part)))" "(defn- sum [ & args] \\r\\n  (apply reduce + 0 args)) \\r\\n\\r\\n\\r\\n(defn- cost-of-approximation \\r\\n   \\"by-part-cost is a function of two numbers that should \\r\\n    return a cost, decreasing the two numbers approach one another\\" \\r\\n   [cost-function M W H] \\r\\n   (let [costs-by-part \\r\\n         (for [i (range (nrow M)) j (range (ncol M))] \\r\\n           (let [M-i-j (sel M i j) \\r\\n                 WH-i-j (item-in-product i j W H)] \\r\\n             (cost-function M-i-j WH-i-j)))] \\r\\n     (sum costs-by-part))) \\r\\n\\r\\n(defn- item-in-product \\r\\n   \\"Completely for keeping giant matrices out of memory. \\r\\n   Expect this to be much slower (but much less swapular) \\r\\n    than just (sel i j (mmult M N))\\" \\r\\n   [i j M N] \\r\\n  (let [M-row-i (sel M \:rows i) \\r\\n        N-col-j (sel N \:cols j)] \\r\\n    (mmult M-row-i N-col-j)))" "(defn- sum [ & args] \\r\\n  (apply reduce + 0 args)) \\r\\n\\r\\n(defn- item-in-product \\r\\n   \\"Completely for keeping giant matrices out of memory. \\r\\n   Expect this to be much slower (but much less swapular) \\r\\n    than just (sel i j (mmult M N))\\" \\r\\n   [i j M N] \\r\\n  (let [M-row-i (sel M \:rows i) \\r\\n        N-col-j (sel N \:cols j)] \\r\\n    (mmult M-row-i N-col-j))) \\r\\n\\r\\n(defn- cost-of-approximation \\r\\n   \\"by-part-cost is a function of two numbers that should \\r\\n    return a cost, decreasing the two numbers approach one another\\" \\r\\n   [cost-function M W H] \\r\\n   (let [costs-by-part \\r\\n         (for [i (range (nrow M)) j (range (ncol M))] \\r\\n           (let [M-i-j (sel M i j) \\r\\n                 WH-i-j (item-in-product i j W H)] \\r\\n             (cost-function M-i-j WH-i-j)))] \\r\\n     (sum costs-by-part)))" "(cost-of-approximation  euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000)\\n           (random-matrix 1000 1000))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(defn- calculate-v1\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (atom 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (f (sel  m1 i j) (sel m2 i j)))]\\r\\n    (reduce + ff)))" "(calculate-v1 euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(defn \\"nfm algoritham implementation\\" factorize [v nf iter] \\r\\n  (let [w (random-matrix (nrow v) nf)\\r\\n        h (random-matrix nf (ncol v))]     \\r\\n    (loop [i 0]  \\r\\n      (when (< i iter)    \\r\\n        [w h]  \\r\\n        (if (% i 10) (println i)\\r\\n        (recur \\r\\n          (inc i)))))))" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [w (random-matrix (nrow v) nf)\\r\\n        h (random-matrix nf (ncol v))]     \\r\\n    (loop [i 0]  \\r\\n      (when (< i iter)    \\r\\n        [w h]  \\r\\n        (if (% i 10) (println i)\\r\\n        (recur \\r\\n          (inc i)))))))" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [w (random-matrix (nrow v) nf)\\r\\n        h (random-matrix nf (ncol v))]     \\r\\n    (loop [i 0]  \\r\\n      (when (< i iter)    \\r\\n        [w h]  \\r\\n        (if (mod i 10) (println i)\\r\\n        (recur \\r\\n          (inc i)))))))" "(factorize \\n  (matrix [1 2 3 4 5 6 7 8 9] 3) 2 20)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [w (random-matrix (nrow v) nf)\\r\\n        h (random-matrix nf (ncol v))]     \\r\\n    (loop [i 0]  \\r\\n      (when (> i iter)    \\r\\n        [w h]  \\r\\n        (if (mod i 10) (println i)\\r\\n        (recur \\r\\n          (inc i)))))))" "(factorize \\n  (matrix [1 2 3 4 5 6 7 8 9] 3) 2 20)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [w (random-matrix (nrow v) nf)\\r\\n        h (random-matrix nf (ncol v))]  \\n    [w h] ))" "(factorize \\n  (matrix [1 2 3 4 5 6 7 8 9] 3) 2 20)" " (loop [i 0]  \\r\\n      (when (> i 20)    \\r\\n        [w h]  \\r\\n        (if (\= (mod i 2) 0) \\n          (println i)\\r\\n        (recur \\r\\n          (inc i)))))" " (loop [i 0]  \\r\\n      (when (> i 20)    \\r\\n        i  \\r\\n        (if (\= (mod i 2) 0) \\n         (println i)\\r\\n        (recur \\r\\n          (inc i)))))" " \\r\\n(loop [x 10] \\r\\n  (when (> x 1) \\r\\n\\r\\n    (println x) \\r\\n\\r\\n    (recur (- x 2))))" " \\r\\n(loop [i 10] \\r\\n  (when (> i 1) \\r\\n    (println i) \\r\\n    (recur (- i 1))))" " \\r\\n(loop [i 10] \\r\\n  (when (> i 1) \\r\\n    (println i) \\r\\n    (recur (- i 1) i)))" " \\r\\n(loop [i 10] \\r\\n  (when (> i 1) \\r\\n    (println i) \\r\\n    (recur (- i 1) )))" " \\r\\n(loop [i 10] \\r\\n  (if (< i 0) \\r\\n    (println i) \\r\\n    (recur (- i 1) )))" " \\r\\n(loop [i 10] \\r\\n  (if (< i 0) \\r\\n    i \\r\\n    (recur (- i 1) )))" "(loop [i 0]  \\r\\n  (when (< i 5)    \\r\\n    (println i)    \\r\\n    (recur (inc i)); loop i will take this value\\r\\n))" "(loop [i 0]  \\r\\n  (when (\= (mod i 2) 0)    \\r\\n    (println i)    \\r\\n    (recur (inc i)); loop i will take this value\\r\\n))" " \\r\\n(loop [i 10] \\r\\n  (if (< i 0) \\r\\n    ( i \\r\\n    (when (\= (mod i 2) 0) \\n      (recur (- i 1) )))))" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [w (random-matrix (nrow v) nf)\\r\\n        h (random-matrix nf (ncol v))]     \\r\\n    (loop [i iter]  \\r\\n       (if (< i 0) [w h]\\r\\n        (recur (dec i))))))" "(factorize \\n  (matrix [1 2 3 4 5 6 7 8 9] 3)\\n  2 20)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter]   \\r\\n    (loop [i iter \\r\\n          w (random-matrix (nrow v) nf)\\r\\n          h (random-matrix nf (ncol v))]  \\r\\n     (if (< i 0) [w h]\\r\\n       (let [wh  (mult w h)\\r\\n             diff (calculate euclidean-distance v h)]  \\r\\n         (if (\= diff 0)\\r\\n           [w h]\\r\\n            (recur (dec i) w h))))))" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter]   \\r\\n    (loop [i iter \\r\\n          w (random-matrix (nrow v) nf)\\r\\n          h (random-matrix nf (ncol v))]  \\r\\n     (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n             diff (calculate euclidean-distance v h)]  \\r\\n         (if (\= diff 0)\\r\\n           [w h]\\r\\n            (recur (dec i) w h))))))" "(factorize \\n  (matrix [1 2 3 4 5 6 7 8 9] 3)\\n  2 20)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter]   \\r\\n    (loop [i iter \\r\\n          w (random-matrix (nrow v) nf)\\r\\n          h (random-matrix nf (ncol v))]  \\r\\n     (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n             diff (calculate euclidean-distance v wh)]  \\r\\n         (if (\= diff 0)\\r\\n           [w h]\\r\\n            (recur (dec i) w h))))))" "(factorize \\n  (matrix [1 2 3 4 5 6 7 8 9] 3)\\n  2 20)" "(- [1 2 3 4 5] [1 2 3 4 5])" "(defn- calculate-v1\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       iterat (for [i (range  (nrow m1)) j (range (ncol m1))] [i j])\\r\\n       ff (fn [aggr i j] \\r\\n            (+ agg (f (sel  m1 i j) (sel m2 i j))))]\\r\\n    (reduce ff 0 iterat)))" "(defn- calculate-v1\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       iterat (for [i (range  (nrow m1)) j (range (ncol m1))] [i j])\\r\\n       ff (fn [aggr i j] \\r\\n            (+ aggr (f (sel  m1 i j) (sel m2 i j))))]\\r\\n    (reduce ff 0 iterat)))" "(calculate + \\n           (matrix [1 2 3 4 5 6 7 8 9] 3)\\n              (matrix [1 2 3 4 5 6 7 8 9] 3))" "(+ 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 )" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(defn- calculate-v1\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       a (atom 0)\\r\\n       ff (for [i (range  (nrow m1)) j (range (ncol m1))] \\r\\n            (swap\! a +  (f (sel  m1 i j) (sel m2 i j))))]\\r\\n    (last ff)))\\r\\n\\r\\n(defn- random-matrix\\r\\n  \\"Generates a random matrix size ixj  \\r\\n[(1 1) ... (i 1)]\\r\\n...\\r\\n[(1 j) ... (i j)]\\"\\r\\n  [i j]\\r\\n  (let [element-count (* i j) \\r\\n        randoms (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)] \\r\\n    (matrix randoms j)))\\r\\n\\r\\n;;v1\\r\\n(defn- calculate-v2\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       iterat (for [i (range  (nrow m1)) j (range (ncol m1))] [i j])\\r\\n       ff (fn [aggr i j] \\r\\n            (+ aggr (f (sel  m1 i j) (sel m2 i j))))]\\r\\n    (reduce ff 0 iterat)))\\r\\n\\r\\n(def- calculate calculate-v2)" "(def calculate calculate-v2)" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(calculate-v2 euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(defn- calculate-v1\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       iterat (for [i (range  (nrow m1)) j (range (ncol m1))] [i  j])\\r\\n       ff (fn [aggr poss] \\r\\n            (+ aggr (f (sel  m1 (first i) (second j)) (sel m2 (first i) (second j)))))]\\r\\n    (reduce ff 0 iterat)))" "(defn- calculate-v1\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       iterat (for [i (range  (nrow m1)) j (range (ncol m1))] [i  j])\\r\\n       ff (fn [aggr poss] \\r\\n            (+ aggr (f (sel  m1 (first poss) (second poss)) (sel m2 (first poss) (second poss)))))]\\r\\n    (reduce ff 0 iterat)))" "(calculate-v1 euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(calculate euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(calculate-v2 euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(defn- calculate-v2\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       iterat (for [i (range  (nrow m1)) j (range (ncol m1))] [i  j])\\r\\n       ff (fn [aggr poss] \\r\\n            poss\\n            )]\\r\\n    (reduce ff 0 iterat)))" "(calculate-v2 euclidean-distance \\n           (random-matrix 3 3) \\n           (random-matrix 3 3))" "(defn- calculate-v2\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       iterat (for [i (range  (nrow m1)) j (range (ncol m1))] [i  j])\\r\\n       ff (fn [aggr poss] \\r\\n            (+ aggr (f (sel  m1 (first poss) (second poss)) (sel m2 (first poss) (second poss)))))]\\r\\n    (reduce ff 0 iterat)))" "(calculate-v2 euclidean-distance \\n           (random-matrix 3 3) \\n           (random-matrix 3 3))" "(defn- calculate-v2\\r\\n  \\"The calculate function loops over every value in\\r\\ntwo equal-sized matrices and sums the moduo between them.\\"\\r\\n   [f m1 m2]\\r\\n (let [\\r\\n       iterat (for [i (range  (nrow m1)) j (range (ncol m1))] [i  j])\\r\\n       ff (fn [aggr [i j]] \\r\\n            (+ aggr (f (sel  m1 i j) (sel m2 i j))))]\\r\\n    (reduce ff 0 iterat)))" "(calculate-v2 euclidean-distance \\n           (random-matrix 3 3) \\n           (random-matrix 3 3))" "(defn- calculate-v2\\r\\n     \\"The calculate function loops over every value in\\r\\n   two equal-sized matrices and sums the moduo between them.\\"\\r\\n      [f m1 m2]\\r\\n    (let [\\r\\n          iterat (for [i (range  (nrow m1)) j (range (ncol m1))] [i  j])\\r\\n          ff (fn [aggr [i j]] \\r\\n               (+ aggr (f (sel  m1 i j) (sel m2 i j))))]\\r\\n       (reduce ff 0 iterat)))" "(calculate-v2 euclidean-distance \\n           (random-matrix 3 3) \\n           (random-matrix 3 3))" "(calculate-v2 euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" "(calculate-v1 euclidean-distance \\n           (random-matrix 1000 1000) \\n           (random-matrix 1000 1000))" ";Update feature matrix\\r\\n(defn- update-feature-matrix [v w h]\\r\\n  (let [w-trans (trans w)\\r\\n        hn (mmult w-trans v) \\r\\n        hd (mmult w-trans w h)\\r\\n        for-ij (for [i (range (nrow h)) j (range (ncol h))] [i  j])\\r\\n        ff (fn [[i j]]\\r\\n           (* (sel h i j) \\r\\n              (sel hn i j) \\r\\n              (recip (sel  hd i j))))]\\r\\n    (matrix (map ff for-ij) (ncol h))))\\r\\n\\r\\n;Update weights matrix\\r\\n(defn- update-feature-matrix [v w h]\\r\\n  (let [h-trans (trans h)\\r\\n        hn (mmult v h-trans) \\r\\n        hd (mmult w h h-trans)\\r\\n        for-ij (for [i (range (nrow h)) j (range (ncol h))] [i  j])\\r\\n        ff (fn [[i j]]\\r\\n           (* (sel h i j) \\r\\n              (sel hn i j) \\r\\n              (recip (sel  hd i j))))]\\r\\n    (matrix (map ff for-ij) (ncol h))))" ";Update feature matrix\\r\\n(defn- update-feature-matrix [v w h]\\r\\n  (let [w-trans (trans w)\\r\\n        hn (mmult w-trans v) \\r\\n        hd (mmult w-trans w h)\\r\\n        for-ij (for [i (range (nrow h)) j (range (ncol h))] [i  j])\\r\\n        ff (fn [[i j]]\\r\\n          (/ (* (sel h i j) (sel hn i j)) \\r\\n              (sel  hd i j)))]\\r\\n    (matrix (map ff for-ij) (ncol h))))\\r\\n\\r\\n;Update weights matrix\\r\\n(defn- update-feature-matrix [v w h]\\r\\n  (let [h-trans (trans h)\\r\\n        hn (mmult v h-trans) \\r\\n        hd (mmult w h h-trans)\\r\\n        for-ij (for [i (range (nrow h)) j (range (ncol h))] [i  j])\\r\\n        ff (fn [[i j]]\\r\\n           (/ (* (sel h i j) \\r\\n              (sel hn i j)) \\r\\n               (sel  hd i j)))]\\r\\n    (matrix (map ff for-ij) (ncol h))))" "(def M1 (random-matrix 3 3)" "(def M1 (random-matrix 3 3))" "M1" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter]   \\r\\n    (loop [i iter \\r\\n          w (random-matrix (nrow v) nf)\\r\\n          h (random-matrix nf (ncol v))\\r\\n          \\r\\n          for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])]  \\r\\n     (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n             cost (calculate euclidean-distance v wh)]  \\r\\n         (if (\= cost 0)\\r\\n           [w h]\\r\\n           (let [h (update-feature-matrix v w h)\\r\\n                 w (update-weights-matrix v w h) ]\\r\\n            (recur (dec i) w h)))))))" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n           (if (< i 0) [w h]\\r\\n             (let [wh  (mmult w h)\\r\\n                   cost (calculate euclidean-distance v wh)]  \\r\\n               (if (\= cost 0)\\r\\n                 [w h]\\r\\n                 (let [h (update-feature-matrix v w h)\\r\\n                       w (update-weights-matrix v w h) ]\\r\\n            (recur (dec i) w h))))))))" "(def m1 \\n  (random-matrix 3 3))" "(factorize m1 2 10)" "(defn update-weights-matrix [v w h]\\r\\n  (let [h-trans (trans h)\\r\\n        hn (mmult v h-trans) \\r\\n        hd (mmult w h h-trans)\\r\\n        for-ij (for [i (range (nrow h)) j (range (ncol h))] [i  j])\\r\\n        ff (fn [[i j]]\\r\\n           (/ (* (sel h i j) \\r\\n              (sel hn i j)) \\r\\n               (sel  hd i j)))]\\r\\n    (matrix (map ff for-ij) (ncol h))))" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] )))" "(factorize m1 2 10)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] [wh cost] )))))" "(factorize m1 2 10)" "m1" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] [w h] )))))" "(factorize m1 2 10)" "(def a (factorize m1 2 10))" "(defn update-weights-matrix [v w h]\\r\\n  (let [h-trans (trans h)\\r\\n        hn (mmult v h-trans) \\r\\n        hd (mmult w h h-trans)\\r\\n        for-ij (for [i (range (nrow h)) j (range (ncol h))] [i  j])\\r\\n        ff (fn [[i j]]\\r\\n           (/ (* (sel h i j) \\r\\n              (sel hn i j)) \\r\\n               (sel  hd i j)))]\\r\\n    (matrix (map ff for-ij) (ncol h))))" "(update-weights-matrix m1 \\n                       (first a) (second a))" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          (if (\= cost 0)\\r\\n                [w h]\\r\\n                 (let [h (update-feature-matrix v w h)\\r\\n                       w (update-weights-matrix v w h) ]\\r\\n           (recur (dec i) w h))))))))" "(def a (factorize m1 2 10))" "(defn update-feature-matrix [v w h]\\r\\n  (let [w-trans (trans w)\\r\\n        hn (mmult w-trans v) \\r\\n        hd (mmult w-trans w h)\\r\\n        for-ij (for [i (range (nrow h)) j (range (ncol h))] [i  j])\\r\\n        ff (fn [[i j]]\\r\\n          (/ (* (sel h i j) (sel hn i j)) \\r\\n              (sel  hd i j)))]\\r\\n    (matrix (map ff for-ij) (ncol h))))" "(defn update-feature-matrix [v w h]\\r\\n  [w h])" "(def a (factorize m1 2 10))" "(defn update-feature-matrix [v w h]\\r\\n (println [w h]))" "(def a (factorize m1 2 10))" "(defn update-weights-matrix [v w h]\\r\\n (println [w h]))" "(def a (factorize m1 2 10))" "(trace-forms \\n  (factorize m1 2 5))" "(use clojure.tools.trace)" " (use 'clojure.tools.trace)" "(def m1 \\n  (random-matrix 3 3 ))\\n(trace-forms\\n  (factorize m1 2 5))" "(defn update-feature-matrix [v w h]\\r\\n  [h])" "(defn update-weights-matrix-matrix [v w h]\\r\\n  [w])" "(factorize m1 2 5)" "(def m1 \\n  (random-matrix 3 3 ))" "(factorize m1 2 5)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          (if (\= cost 0)\\r\\n                [w h]\\r\\n                 (let [h (update-feature-matrix v w h)\\r\\n                       w (update-weights-matrix v w h) ]\\r\\n           (recur (dec i) w h))))))))" "(factorize m1 2 5)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          (if (\= cost 0)\\r\\n                [w h]\\r\\n                 (let [h (update-feature-matrix v w h)\\r\\n                       w (update-weights-matrix v w h) ]\\r\\n           [h w] )))))))" "(factorize m1 2 5)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          (if (\= cost 0)\\r\\n                [w h]\\r\\n                 \\r\\n           [h w] ))))))" "(factorize m1 2 5)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          (if (\= cost 0)\\r\\n                [w h]\\r\\n                 (let [h (update-feature-matrix v w h)\\r\\n                       w (update-weights-matrix v w h) ]\\r\\n           [h w] )))))))" "(update-feature-matrix [[1 2][1 2]] [[1] [1]] [[1 1]])" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          (if (\= cost 0)\\r\\n                [w h]\\r\\n                 (let [new-h (update-feature-matrix v w h)\\r\\n                       new-h  (update-weights-matrix v w h) ]\\r\\n           (recur (dec i) w h))))))))" "(factorize m1 2 5)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          ;;(if (\= cost 0)\\r\\n                [w h])))))\\r\\n                 ;;(let [new-h (update-feature-matrix v w h)\\r\\n                    ;;   new-h  (update-weights-matrix v w h) ]\\r\\n           ;;(recur (dec i) w h))))))))" "(factorize m1 2 5)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          (if (\= cost 0)\\r\\n                [w h])))))\\r\\n                 (let [new-h (update-feature-matrix v w h)\\r\\n                       new-w  (update-weights-matrix v w h) ]\\n                   [new-h new-w]))\\r\\n           ;;(recur (dec i) w h))))))))" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)]           \\r\\n                 (let [new-h (update-feature-matrix v w h)\\r\\n                       new-w  (update-weights-matrix v w h) ]\\n                   [new-h new-w]))))))\\r\\n           ;;(recur (dec i) w h))))))))" "(factorize m1 2 5)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)]                          \\n                   [new-h new-w])))))\\r\\n           ;;(recur (dec i) w h))))))))" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)]                          \\n                   [w h])))))\\r\\n           ;;(recur (dec i) w h))))))))" "(factorize m1 2 5)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)]                          \\n                   [(update-weights-matrix w)])))))\\r\\n           ;;(recur (dec i) w h))))))))" "(factorize m1 2 5)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)]                          \\n                   [(update-weights-matrix v w h)])))))\\r\\n           ;;(recur (dec i) w h))))))))" "(factorize m1 2 5)" "update-feature-matrix" "(update-feature-matrix 0 0 0)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          (if (\= cost 0)\\r\\n                [w h]\\r\\n                ;; (let [new-h (update-feature-matrix v w h)\\r\\n                     ;;  new-h  (update-weights-matrix v w h) ]\\r\\n           (recur (dec i) w h)))))));;)" "(factorize m1 2 5)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          (if (\= cost 0)\\r\\n                [w h]\\r\\n                (let [new-h (update-feature-matrix v w h)\\r\\n                      new-h  (update-weights-matrix v w h) ]\\r\\n           (recur (dec i) w h))))))))" "(factorize m1 2 5)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          (if (\= cost 0)\\r\\n                [w h]\\r\\n                (let [new-h h\\r\\n                      new-w  w ]\\r\\n           (recur (dec i) w h))))))))" "(factorize m1 2 5)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          (if (\= cost 0)\\r\\n                [w h]\\r\\n                (let [new-h (update-feature-matrix v w h)\\r\\n                      new-w (update-weights-matrix-matrix v w h) ]\\r\\n           (recur (dec i) w h))))))))" "(factorize m1 2 5)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          (if (\= cost 0)\\r\\n                [w h]\\r\\n                (let [new-h (update-feature-matrix v w h)\\r\\n                      new-w (update-weights-matrix v w h) ]\\r\\n           (recur (dec i) w h))))))))" "(factorize m1 2 5)" "(defn\\n  update-weights-matrix\\n  [v w h] w)" "(factorize m1 2 5)" "(def test-w (first (factorize m1 2 5)))" "(def test-h (second (factorize m1 2 5)))" "(defn update-weights-matrix [v w h]\\r\\n  (let [h-trans (trans h)\\r\\n        hn (mmult v h-trans) \\r\\n        hd (mmult w h h-trans)\\r\\n        for-ij (for [i (range (nrow h)) j (range (ncol h))] [i  j])\\r\\n        ff (fn [[i j]]\\r\\n           (/ (* (sel h i j) \\r\\n              (sel hn i j)) \\r\\n               (sel  hd i j)))]\\r\\n    (matrix (map ff for-ij) (ncol h))))" "(update-weights-matrix m1 test-w test-h)" "(defn update-weights-matrix [v w h]\\r\\n ;; (let [h-trans \\n        (trans h))\\r\\n      ;;  hn (mmult v h-trans) \\r\\n     ;;   hd (mmult w h h-trans)\\r\\n     ;;   for-ij (for [i (range (nrow h)) j (range (ncol h))] [i  j])\\r\\n     ;;   ff (fn [[i j]]\\r\\n    ;;       (/ (* (sel h i j) \\r\\n      ;;        (sel hn i j)) \\r\\n       ;;        (sel  hd i j)))]\\r\\n   ;; (matrix (map ff for-ij) (ncol h))))" "(update-weights-matrix m1 test-w test-h)" "(defn update-weights-matrix [v w h]\\r\\n  (let [h-trans \\n       (trans h)\\r\\n       hn (mmult v h-trans) ] hn))\\r\\n    ;;   hd (mmult w h h-trans)\\r\\n    ;;   for-ij (for [i (range (nrow h)) j (range (ncol h))] [i  j])\\r\\n    ;;   ff (fn [[i j]]\\r\\n   ;;       (/ (* (sel h i j) \\r\\n     ;;        (sel hn i j)) \\r\\n      ;;        (sel  hd i j)))]\\r\\n  ;; (matrix (map ff for-ij) (ncol h))))" "(update-weights-matrix m1 test-w test-h)" "(defn update-weights-matrix [v w h]\\r\\n  (let [h-trans \\n       (trans h)\\r\\n       hn (mmult v h-trans) \\r\\n       hd (mmult w h h-trans)] hd))\\r\\n    ;;   for-ij (for [i (range (nrow h)) j (range (ncol h))] [i  j])\\r\\n    ;;   ff (fn [[i j]]\\r\\n   ;;       (/ (* (sel h i j) \\r\\n     ;;        (sel hn i j)) \\r\\n      ;;        (sel  hd i j)))]\\r\\n  ;; (matrix (map ff for-ij) (ncol h))))" "(update-weights-matrix m1 test-w test-h)" "(defn update-weights-matrix [v w h]\\r\\n  (let [h-trans \\n       (trans h)\\r\\n       hn (mmult v h-trans) \\r\\n       hd (mmult w h h-trans)\\r\\n       for-ij (for [i (range (nrow w)) j (range (ncol w))] [i  j])\\r\\n   ] hd))\\n       ;;   ff (fn [[i j]]\\r\\n   ;;       (/ (* (sel h i j) \\r\\n     ;;        (sel hn i j)) \\r\\n      ;;        (sel  hd i j)))]\\r\\n  ;; (matrix (map ff for-ij) (ncol h))))" "(update-weights-matrix m1 test-w test-h)" "(defn update-weights-matrix [v w h]\\r\\n  (let [h-trans \\n       (trans h)\\r\\n       hn (mmult v h-trans) \\r\\n       hd (mmult w h h-trans)\\r\\n       for-ij (for [i (range (nrow w)) j (range (ncol w))] [i  j])\\n          ff (fn [[i j]]\\r\\n          (/ (* (sel h i j) \\r\\n             (sel hn i j)) \\r\\n             (sel  hd i j)))]\\r\\n   (matrix (map ff for-ij) (ncol w))))" "(update-weights-matrix m1 test-w test-h)" "(defn update-feature-matrix [v w h]\\r\\n  (let [w-trans (trans w)\\r\\n        hn (mmult w-trans v) \\r\\n        hd (mmult w-trans w h)\\r\\n        for-ij (for [i (range (nrow h)) j (range (ncol h))] [i  j])\\r\\n        ff (fn [[i j]]\\r\\n          (/ (* (sel h i j) (sel hn i j)) \\r\\n              (sel  hd i j)))]\\r\\n    (matrix (map ff for-ij) (ncol h))))" "(update-feature-matrix-matrix m1 test-w test-h)" ";Update feature matrix\\r\\n(defn update-feature-matrix [v w h]\\r\\n  (let [w-trans (trans w)\\r\\n        hn (mmult w-trans v) \\r\\n        hd (mmult w-trans w h)\\r\\n        for-ij (for [i (range (nrow w)) j (range (ncol w))] [i  j])\\r\\n        ff (fn [[i j]]\\r\\n          (/ (* (sel h i j) (sel hn i j)) \\r\\n              (sel  hd i j)))]\\r\\n    (matrix (map ff for-ij) (ncol h))))\\r\\n\\r\\n;Update weights matrix\\r\\n(defn update-weights-matrix [v w h]\\r\\n     (let [h-trans (trans h)\\r\\n          wn (mmult v h-trans) \\r\\n          wd (mmult w h h-trans)\\r\\n          for-ij (for [i (range (nrow w)) j (range (ncol w))] [i  j])\\r\\n             ff (fn [[i j]]\\r\\n             (/ (* (sel h i j) \\r\\n                (sel wn i j)) \\r\\n                (sel  wd i j)))]\\r\\n      (matrix (map ff for-ij) (ncol w))))" "(update-feature-matrix-matrix m1 test-w test-h)" "(update-feature-matrix m1 test-w test-h)" "(update-weights-matrix-matrix m1 test-w test-h)" "(factorize m1 2 5)" "(defn update-feature-matrix [v w h]\\r\\n  (let [w-trans (trans w)\\r\\n        hn (mmult w-trans v) \\r\\n        hd (mmult w-trans w h)\\r\\n        for-ij (for [i (range (nrow h)) j (range (ncol h))] [i  j])\\r\\n        ff (fn [[i j]]\\r\\n          (/ (* (sel h i j) (sel hn i j)) \\r\\n              (sel  hd i j)))]\\r\\n    (matrix (map ff for-ij) (ncol h))))\\r\\n\\r\\n;Update weights matrix\\r\\n(defn update-weights-matrix [v w h]\\r\\n     (let [h-trans (trans h)\\r\\n          wn (mmult v h-trans) \\r\\n          wd (mmult w h h-trans)\\r\\n          for-ij (for [i (range (nrow w)) j (range (ncol w))] [i  j])\\r\\n             ff (fn [[i j]]\\r\\n             (/ (* (sel h i j) \\r\\n                (sel wn i j)) \\r\\n                (sel  wd i j)))]\\r\\n      (matrix (map ff for-ij) (ncol w))))" "(factorize m1 2 5)" "(defn update-feature-matrix [v w h]\\r\\n  (let [w-trans (trans w)\\r\\n        hn (mmult w-trans v) \\r\\n        hd (mmult w-trans w h)\\r\\n        for-ij (for [i (range (nrow h)) j (range (ncol h))] [i  j])\\r\\n        ff (fn [[i j]]\\r\\n          (/ (* (sel h i j) (sel hn i j)) \\r\\n              (sel  hd i j)))]\\r\\n    (matrix (map ff for-ij) (ncol h))))" "(def test-h (random-matrix 3 2))\\r\\n(def test-w (random-matrix 2 3))\\r\\n\\r\\n\\r\\n(def m1 (matrix [[1 2 3]\\r\\n                 [4 5 6]\\r\\n                 [7 8 9]]))" "(test-h)" "test-h" "(def test-h (random-matrix 2 3))\\r\\n(def test-w (random-matrix 3 2))\\r\\n\\r\\n\\r\\n(def m1 (matrix [[1 2 3]\\r\\n                 [4 5 6]\\r\\n                 [7 8 9]]))" "(update-feature-matrix m1 \\n                       test-w test-h)" "(update-weights-matrix-matrix m1 \\n                       test-w test-h)" "(update-weights-matrix m1 \\n                       test-w test-h)" ";Update feature matrix\\r\\n(defn update-feature-matrix [v w h]\\r\\n  (let [w-trans (trans w)\\r\\n        hn (mmult w-trans v) \\r\\n        hd (mmult w-trans w h)\\r\\n        for-ij (for [i (range (nrow h)) j (range (ncol h))] [i  j])\\r\\n        ff (fn [[i j]]\\r\\n          (/ (* (sel h i j) (sel hn i j)) \\r\\n              (sel  hd i j)))]\\r\\n    (matrix (map ff for-ij) (ncol h))))\\r\\n\\r\\n;Update weights matrix\\r\\n(defn update-weights-matrix [v w h]\\r\\n  (let [h-trans \\r\\n       (trans h)\\r\\n       hn (mmult v h-trans) \\r\\n       hd (mmult w h h-trans)\\r\\n       for-ij (for [i (range (nrow w)) j (range (ncol w))] [i  j])\\r\\n          ff (fn [[i j]]\\r\\n          (/ (* (sel h i j) \\r\\n             (sel hn i j)) \\r\\n             (sel  hd i j)))]\\r\\n   (matrix (map ff for-ij) (ncol w))))" "(update-weights-matrix m1 \\n                       test-w test-h)" "(update-feature-matrix m1 \\n                       test-w test-h)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          (if (\= cost 0)\\r\\n                [w h]\\r\\n                (let [new-h (update-feature-matrix v w h)\\r\\n                      new-w (update-weights-matrix v w h) ]\\r\\n           (recur (dec i) new-h new-w))))))))" "(factorize m1 2 10)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\n       (do (print w) (print h)\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          (if (\= cost 0)\\r\\n                [w h]\\r\\n                (let [new-h (update-feature-matrix v w h)\\r\\n                      new-w (update-weights-matrix v w h) ]\\r\\n           (recur (dec i) new-h new-w)))))))))" "(factorize m1 2 10)" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])] \\r\\n    (loop [i iter \\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n      [w h] \\r\\n      (if (< i 0) [w h]\\r\\n       (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n          (if (\= cost 0)\\r\\n                [w h]\\r\\n                (let [new-h (update-feature-matrix v w h)\\r\\n                      new-w (update-weights-matrix v w h) ]\\r\\n           (recur (dec i)  new-w new-h))))))))" "(factorize m1 2 10)" "(def a  (factorize m1 2 10) )" "(first a)" "(mmult (first a) (second a))" "(def a  (factorize m1 2 10) )" "(mmult (first a) (second a))" "(first a)" "(def a  (factorize m1 2 100) )" "(first a)" "(def a  (factorize m1 2 100) )" "(first a)" "(mmult (first a) (second a))" "(def a  (factorize m1 2 1000) )" "(mmult (first a) (second a))" "(def a  (factorize m1 2 1000) )" "(first a)" "(mmult \\n  (first a) \\n  (second a))" "(def a  (factorize m1 2 1000) )" "(mmult \\n  (first a) \\n  (second a))" "(first a)" "(second a)" "(def a  (factorize m1 2 1000) )" "(second a)" "(first a)" "(mmult \\n  (first a) \\n  (second a))" "(def a  (factorize m1 2 1000) )" "(nma/non-negative-factor-approx demo-src-image [[1 2 3]\\n                                                [4 5 6]\\n                                                [7 8 9]]\\r\\n                                              \:max-tries 100\\r\\n                                              \:chatty true)" "(non-negative-factor-approx demo-src-image [[1 2 3]\\n                                            [4 5 6]\\n                                            [7 8 9]]\\r\\n                                              \:max-tries 100\\r\\n                                              \:chatty true)" "(ns nma.demo\\r\\n  (\:require [clojure.java.io \:as jio]\\r\\n            [incanter.core \:as incanter]\\r\\n            [nma.simple \:as nma])\\r\\n  (\:import [javax.imageio ImageIO]\\r\\n           [java.awt.image BufferedImage]))\\r\\n\\r\\n(defn read-image-matrix [imagefile]\\r\\n  (let [imagefile (jio/as-file imagefile)\\r\\n        raster (.. (. ImageIO read imagefile) getData)\\r\\n        left (. raster getMinX)\\r\\n        width (. raster getWidth)\\r\\n        right (+ left width)\\r\\n        top (. raster getMinY)\\r\\n        height (. raster getHeight)\\r\\n        bottom (+ top height)\\r\\n        xrange (range left right)\\r\\n        yrange (range top bottom)]\\r\\n    (incanter/matrix\\r\\n     (for [row yrange]\\r\\n       (for [column xrange]\\r\\n         (let [pixel (. raster getPixel column row nil)]\\r\\n           (/ (reduce + 0 (seq pixel)) (alength pixel))))))))\\r\\n\\r\\n(defn write-image-matrix [imagefile M]\\r\\n  (let [imagefile (jio/as-file imagefile)\\r\\n        width (incanter/ncol M)\\r\\n        height (incanter/nrow M)\\r\\n        image (BufferedImage. width height BufferedImage/TYPE_BYTE_GRAY)\\r\\n        raster (. image getRaster)]\\r\\n    (doseq [row (range height) column (range width)]\\r\\n      (. raster setPixel column row (float-array 1 (incanter/sel M row column))))\\r\\n    (. ImageIO write image \\"png\\" imagefile)))\\r\\n\\r\\n\\r\\n(defn image-demo\\r\\n  \\"Will extract features from in-image-file, and write\\r\\n   a reconstructed image to out-image-file. A bit useless,\\r\\n   but a nice way to visualize the quality of a factorization,\\r\\n   get a sense for how artifacts show up, etc.\\"\\r\\n  [in-image-file out-image-file features]\\r\\n  (let [demo-src-image (read-image-matrix in-image-file)\\r\\n        [W H] (nma/non-negative-factor-approx demo-src-image features\\r\\n                                              \:max-tries 100\\r\\n                                              \:chatty true)\\r\\n        matrix-size (fn [M] (* (incanter/ncol M) (incanter/nrow M)))\\r\\n        old-size (matrix-size demo-src-image)\\r\\n        new-size (+ (matrix-size W) (matrix-size H))\\r\\n        demo-reconstructed (incanter/mmult W H)]\\r\\n    (println \\"Compressed image from \\" old-size \\" to \\" new-size)\\r\\n    (write-image-matrix out-image-file demo-reconstructed)))" "(ns nma.simple\\r\\n  (\:require [incanter.core \:as incanter]\\r\\n            [incanter.stats \:as stats])\\r\\n  (\:use [incanter.core \:only [matrix sel nrow ncol mmult trans]])\\r\\n  (\:import [cern.colt.matrix.tdouble DoubleMatrix2D]))\\r\\n\\r\\n\\"POINT BY POINT IMPLIMENTATION OF\\r\\n \\\\\\"Algorithms for Non-negative Matrix Factorization\\\\\\"\\r\\n By Daniel D. Lee and H. Sebastian Seung, 2001\\"\\r\\n\\r\\n(defn- random-matrix\\r\\n  [rows columns] ;; OR rows columns max-range?\\r\\n  (let [element-count (* rows columns)\\r\\n        randoms (stats/sample-uniform element-count \:min Double/MIN_VALUE \:max 2)]\\r\\n    (matrix randoms columns)))\\r\\n\\r\\n(defn- sum [ & args]\\r\\n  (apply reduce + 0 args))\\r\\n\\r\\n(defn- recip [x] (/ 1 x))\\r\\n\\r\\n(defn- item-in-product\\r\\n  \\"Completely for keeping giant matrices out of memory.\\r\\n   Expect this to be much slower (but much less swapular)\\r\\n   than just (sel i j (mmult M N))\\"\\r\\n  [i j M N]\\r\\n  (let [M-row-i (sel M \:rows i)\\r\\n        N-col-j (sel N \:cols j)]\\r\\n    (mmult M-row-i N-col-j)))\\r\\n\\r\\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\\r\\n\\r\\n(defn- euclidean-distance-squared\\r\\n  [ x y ]\\r\\n  (let [delta (- x y)]    \\r\\n    (* delta delta)))\\r\\n\\r\\n;; For M (n,m) W(n,q) H(q,m)\\r\\n;; improve functions run in n*n*q*q*m*m time\!\\r\\n;; So choose small q, and go get some coffee...\\r\\n(defn- improve-H-distance  \\r\\n  [M W H]\\r\\n\\r\\n  (let [W-trans (trans W)\\r\\n        W-trans-W (mmult W-trans W)\\r\\n        W-trans-M (mmult W-trans M)\\r\\n        W-trans-W-H (mmult W-trans-W H)\\r\\n        H-indexes (for [i (range (nrow H)) j (range (ncol H))] [i j])\\r\\n\\r\\n        ;; Take a closer look at incanter matrix api, you're\\r\\n        ;; missing stuff here.\\r\\n        H-element-at\\r\\n        (fn [[i j]]\\r\\n          (* (sel H i j)\\r\\n             (sel W-trans-M i j)\\r\\n             (recip (sel W-trans-W-H i j))))\\r\\n        H-elements (map H-element-at H-indexes)]\\r\\n    (matrix H-elements (ncol H))))\\r\\n\\r\\n(defn- improve-W-distance\\r\\n  [M W H]\\r\\n  (let [H-trans (trans H)\\r\\n        H-H-trans (mmult H H-trans)\\r\\n        M-H-trans (mmult M H-trans)\\r\\n        W-H-H-trans (mmult W H-H-trans)\\r\\n        W-indexes (for [i (range (nrow W)) j (range (ncol W))] [i j])\\r\\n        W-element-at\\r\\n        (fn [[i j]]\\r\\n          (* (sel W i j)\\r\\n             (sel M-H-trans i j)\\r\\n             (recip (sel W-H-H-trans i j))))\\r\\n        W-elements (map W-element-at W-indexes)]\\r\\n    (matrix W-elements (ncol W))))\\r\\n\\r\\n(def distance-costs\\r\\n  ^{\:doc \\"Cost fn and minimizers associated with euclidean distance between matrices\\"}\\r\\n  {\:calculate-cost euclidean-distance-squared\\r\\n   \:improve-W improve-W-distance\\r\\n   \:improve-H improve-H-distance})\\r\\n\\r\\n(defn- cost-of-approximation\\r\\n  \\"by-part-cost is a function of two numbers that should\\r\\n   return a cost, decreasing the two numbers approach one another\\"\\r\\n  [cost-function M W H]\\r\\n  (let [costs-by-part\\r\\n        (for [i (range (nrow M)) j (range (ncol M))]\\r\\n          (let [M-i-j (sel M i j)\\r\\n                WH-i-j (item-in-product i j W H)]\\r\\n            (cost-function M-i-j WH-i-j)))]\\r\\n    (sum costs-by-part)))\\r\\n\\r\\n(defn factorings\\r\\n  \\"given an n x m matrix M, and integer r,\\r\\n   Produces an (EXPENSIVE, INFINITE) LAZY SEQUENCE OF [ cost W H ]\\r\\n   Where W is an n x r matrix, H is an r x m matrix,\\r\\n   and cost is a measure of how closely W H approximates M,\\r\\n   decreasing as the approximation improves.\\"  \\r\\n  ([M r]\\r\\n     (factorings distance-costs M r))  \\r\\n  ([costs M r]\\r\\n     (let [M (matrix M)\\r\\n           M-rows (nrow M)\\r\\n           M-cols (ncol M)\\r\\n           W (random-matrix M-rows r)\\r\\n           H (random-matrix r M-cols)\\r\\n           \\r\\n           find-cost (partial cost-of-approximation (costs \:calculate-cost))\\r\\n           improve-W (costs \:improve-W)\\r\\n           improve-H (costs \:improve-H)\\r\\n           \\r\\n           next-factoring\\r\\n           (fn [ [_ old-W old-H] ]\\r\\n             (let [new-H (improve-H M old-W old-H)\\r\\n                   new-W (improve-W M old-W new-H)                \\r\\n                   new-cost (find-cost M new-W new-H)]\\r\\n               [new-cost new-W new-H]))]\\r\\n       (iterate next-factoring [nil W H]))))\\r\\n\\r\\n(defn good-enough-factoring\\r\\n  \\"Will iterate \:max-tries, or until cost reduction after iteration\\r\\n   is less than \:threshold-improvement (whichever comes first) and\\r\\n   return [ tries, improvement, [ cost, W and H matrices ] ]\\r\\n   as produced by (factorings costs M r)\\r\\n\\r\\n   threshold-improvement should be expressed as a number in that describes\\r\\n   the maximum interesting ratio of cost[i]/cost[i + 1]\\r\\n   - higher numbers will generally run longer and produce better results,\\r\\n   a value of \\\\\\"1\\\\\\" or more will run (theoretically) forever.\\r\\n\\r\\n   Will impose a \:max-tries of 1000 unless a different argument is provided.\\"  \\r\\n  [factorings &\\r\\n   {\:keys [max-tries threshold-improvement chatty]\\r\\n    \:or {max-tries 1000\\r\\n         threshold-improvement 1.0\\r\\n         chatty false}}]\\r\\n\\r\\n  ;; Yes, this is some (first (reduce (take max-tries factorings))\\r\\n  ;; cleverness, but I actually think the below is pretty straightforward.\\r\\n\\r\\n  ;; PICKING IMPROVEMENT\\r\\n  ;;   improvement as a part of total cost (upside, this is stateless)\\r\\n  \\r\\n  (loop [last-cost nil, tries 0, factorings factorings]\\r\\n    (let [[next-cost _ _ \:as next-try] (first factorings)\\r\\n          improvement (if (and last-cost next-cost)\\r\\n                        (/ next-cost last-cost)\\r\\n                        0)\\r\\n          _ (when chatty\\r\\n              (println \\"Searching for best factorization\\"\\r\\n                       \\"last cost\\" last-cost\\r\\n                       \\"this cost\\" next-cost\\r\\n                       \\"try \\" tries \\",improvement \\" improvement))]\\r\\n      (if (or (< threshold-improvement improvement)\\r\\n              (< max-tries tries))\\r\\n        [tries improvement next-try]\\r\\n        (recur next-cost (inc tries) (rest factorings))))))\\r\\n\\r\\n\\r\\n(defn non-negative-factor-approx\\r\\n  \\"A simple UI for factoring a given matrix with all postive or zero elements, with sensible defaults\\"\\r\\n  [M r & args]\\r\\n  (let [M (matrix M)]\\r\\n    (doseq [ i (range (nrow M)) j (range (ncol M))]\\r\\n      (when-not (<\= 0 (sel M i j))\\r\\n        (throw (Exception. (str \\"Element \\" i \\", \\" j \\" of matrix \=\= \\" (sel M i j) \\", not zero or positive\\")))))    \\r\\n    (let [iterations (factorings M r)\\r\\n          [tries improvement factoring] (apply good-enough-factoring iterations args)\\r\\n          [cost W H] factoring\\r\\n          ]\\r\\n      [W H])))" "(non-negative-factor-approx demo-src-image [[1 2 3]\\n                                            [4 5 6]\\n                                            [7 8 9]]\\r\\n                                              \:max-tries 100\\r\\n                                              \:chatty true)" "(non-negative-factor-approx  [[1 2 3]\\n                              [4 5 6]\\n                              [7 8 9]] 3\\r\\n                                              \:max-tries 100\\r\\n                                              \:chatty true)" "( def (non-negative-factor-approx  [[1 2 3]\\n                                    [4 5 6]\\n                                    [7 8 9]] 3\\r\\n                                              \:max-tries 100\\r\\n                                              \:chatty true))" "( def a (non-negative-factor-approx  [[1 2 3]\\n                                      [4 5 6]\\n                                      [7 8 9]] 3\\r\\n                                              \:max-tries 100\\r\\n                                              \:chatty true))" "(mmult (first a) ( second a))" "(def a  (factorize m1 2 1000) )" "(mmult (first a) ( second a))" "(def a  (factorize m1 2 1000) )" "(defn factorize\\r\\n  \\"nfm algoritham implementation\\"\\r\\n  [v nf iter] \\r\\n  (let [for-ij (for [i (range (nrow v)) j (range (ncol v))] [i  j])\\r\\n                w (random-matrix (nrow v) nf)\\r\\n                h (random-matrix nf (ncol v))]  \\r\\n    (reduce \\r\\n      (fn [[w h]]\\r\\n        (if (< i 0) [w h]\\r\\n          (let [wh  (mmult w h)\\r\\n              cost (calculate euclidean-distance v wh)] \\r\\n             (do (println wh)\\r\\n               (if (\= cost 0)\\r\\n                [w h]\\r\\n                (let [new-h (improve-H-distance  v w h)\\r\\n                      new-w (improve-W-distance v w h) ]\\r\\n          [new-w new-h])))))))))" "(def a  (factorize m1 2 1000) )" "\\r\\n(defn nmf\\r\\n  \\"Non negative factor approx algoritham implementation\\" \\r\\n  [M r & args]\\r\\n  (let [v (matrix v)        \\r\\n        iterations (factorings v r)\\r\\n      [tries improvement factoring] (apply good-enough-factoring iterations args)\\r\\n      [cost W H] factoring\\r\\n          ]\\r\\n      [W H]))" "(defn nmf\\r\\n  \\"Non negative factor approx algoritham implementation\\" \\r\\n  [v r & args]\\r\\n  (let [v (matrix v)        \\r\\n        iterations (factorings v r)\\r\\n      [tries improvement factoring] (apply good-enough-factoring iterations args)\\r\\n      [cost W H] factoring\\r\\n          ]\\r\\n      [W H]))" "(def a  (factorize m1 2 1000) )" "(mmult (first a) ( second a))" "m1" "(first a)" "( second a)" "(mmult (second a) (third a))" "(mmult (second a) (get a 3))" "(mmult (second a) (get a 2))" "(def a  (factorize m1 2 1000) )" "(mmult (second a) (get a 2))" "(def a  (factorize m1 2 1000) )" "(mmult (second a) (get a 2))" "(def a  (factorize m1 2 1000) )" "(mmult (second a) (get a 2))" "(def a  (factorize m1 2 1000) )" "(mmult (second a) (get a 2))" "(def a  (factorize m1 2 1000) )" "(def a  (factorize m2 2 1000) )" "(mmult (second a) (get a 2))" "(def a  (factorize m2 2 1000) )" "(def a  (factorize m1 2 1000) )" "(mmult (second a) (get a 2))" "(def a  (factorize m1 2 1000) )" "(mmult (second a) (get a 2))" "(def a  (factorize m1 2 1000) )" "(mmult (second a) (get a 2))" "(first a)" "(get a 1)" "(get a 2)" "(mmult (second a) (get a 2))" "(def a  (factorize m1 2 1000) )" "(mmult (second a) (get a 2))" "(def a  (factorize m1 2 1000) )" "(mmult (second a) (get a 2))" "(def a  (factorize m1 2 1000) )" "(mmult (second a) (get a 2))" "(defn stock-data [props data]\\r\\n  (reduce (fn [[aggr i],prop]\\r\\n            [(assoc aggr prop \\r\\n                    (nth  item-data i)) (inc i)] ) [{} 0] props))" "\\r\\n(defn stock-data [props data]\\r\\n  (reduce (fn [[aggr i],prop]\\r\\n            [(assoc aggr prop \\r\\n                    (nth  data i)) (inc i)] ) [{} 0] props))" "(stock-data [\:A \:B] [1 2])" "(defn stock-data [props data]\\r\\n  (first (reduce (fn [[aggr i],prop]\\r\\n                   [(assoc aggr prop \\r\\n                           (nth  data i)) \\r\\n                    (inc i)] )) [{} 0] props))" "(stock-data [\:A \:B] [1 2])" "(defn stock-data [props data]\\r\\n  (first (reduce (fn [[aggr i],prop]\\r\\n                   [(assoc aggr prop \\r\\n                           (nth  data i)) \\r\\n                    (inc i)] ) [{} 0] props)))" "(stock-data [\:A \:B] [1 2])" "(with-open [client (http/create-client)]\\r\\n  (let [response (http/GET client \\"http\://neotyk.github.com/http.async.client/\\")\\r\\n        response2 (http/GET client \\"http\://neotyk.github.com/http.async.client/\\") ]\\r\\n    (-> response response2\\r\\n      http/await\\r\\n      http/string )))" "(apply [[1 2 3]] [1 2 3])" "(assoc [[1 2 3]] [1 2 3])" "(assoc [[1 2 3]] 1 [1 2 3])" "(defn- build-ichart-url\\r\\n   [stock-name start-date end-date interval callback] \\r\\n   (str \\"http\://ichart.finance.yahoo.com/table.csv?\\" \\r\\n        \\"s\=\\" stock-name\\r\\n        (if (nil? start-date) \\"\\" \\r\\n          (str \\"&c\=\\" (\:year start-date) \\r\\n               \\"&a\=\\" (\:month start-date)\\r\\n               \\"&b\=\\" (\:day start-date)))\\r\\n        (if (nil? end-date) \\"\\" \\r\\n          (str \\"&d\=\\" (\:month start-date) \\r\\n               \\"&e\=\\" (\:day start-date)\\r\\n               \\"&f\=\\" (\:year start-date)))\\r\\n         (if (nil? interval) \\"\\" \\r\\n          (str \\"&g\=\\" interval))))" "(build-ichart-url \\"MSFT\\" \\n                  {\:year \\"1990\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  {\:year \\"1990\\" \:month \\"00\\" \:day \\"1\\"}\\n                  nil)" "(defn- build-ichart-url\\r\\n   [stock-name start-date end-date interval] \\r\\n   (str \\"http\://ichart.finance.yahoo.com/table.csv?\\" \\r\\n        \\"s\=\\" stock-name\\r\\n        (if (nil? start-date) \\"\\" \\r\\n          (str \\"&c\=\\" (\:year start-date) \\r\\n               \\"&a\=\\" (\:month start-date)\\r\\n               \\"&b\=\\" (\:day start-date)))\\r\\n        (if (nil? end-date) \\"\\" \\r\\n          (str \\"&d\=\\" (\:month start-date) \\r\\n               \\"&e\=\\" (\:day start-date)\\r\\n               \\"&f\=\\" (\:year start-date)))\\r\\n         (if (nil? interval) \\"\\" \\r\\n          (str \\"&g\=\\" interval))))" "(build-ichart-url \\"MSFT\\" \\n                  {\:year \\"1990\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  {\:year \\"1990\\" \:month \\"00\\" \:day \\"1\\"}\\n                  nil)" "(build-ichart-url \\"MSFT\\" \\n                  {\:year \\"1990\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  {\:year \\"2014\\" \:month \\"00\\" \:day \\"1\\"}\\n                  nil)" "(defn- build-ichart-url\\r\\n   [stock-name start-date end-date interval] \\r\\n   (str \\"http\://ichart.finance.yahoo.com/table.csv?\\" \\r\\n        \\"s\=\\" stock-name\\r\\n        (if (nil? start-date) \\"\\" \\r\\n          (str \\"&c\=\\" (\:year start-date) \\r\\n               \\"&a\=\\" (\:month start-date)\\r\\n               \\"&b\=\\" (\:day start-date)))\\r\\n        (if (nil? end-date) \\"\\" \\r\\n          (str \\"&d\=\\" (\:month end-date) \\r\\n               \\"&e\=\\" (\:day end-date)\\r\\n               \\"&f\=\\" (\:year end-date)))\\r\\n         (if (nil? interval) \\"\\" \\r\\n          (str \\"&g\=\\" interval))))" "(build-ichart-url \\"MSFT\\" \\n                  {\:year \\"1990\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  {\:year \\"2014\\" \:month \\"00\\" \:day \\"1\\"}\\n                  nil)" "(build-ichart-url \\"MSFT\\" \\n                  {\:year \\"1990\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  nil\\n                  nil)" "(build-ichart-url \\"MSFT\\" \\n                  {\:year \\"1990\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"w\\")" "(get-historical-stock-information \\"MSFT\\" \\n                  {\:year \\"1990\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"w\\" nil)" "(get-historical-stock-information \\"MSFT\\" \\n                  {\:year \\"2010\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"w\\" (fn [in] in))" "(dissoc [0 2 3 4] 0)" "(dissoc [0 2 3 4] [0])" "\\n(let [a [1 2 3 4]]\\n(filter \#(not\= (first a) %) a))" "(defn convert-csv [data props]   \\r\\n (let [stuff (map (fn [row] \\r\\n                    (let [item-data (clojure.string/split row \#\\",\\")] \\r\\n                     (models/stock-data)))                  \\r\\n(clojure.string/split-lines data 0))]\\r\\n   (remove \#(not\= % (first stuff)))))" "(ns utils.csv\\r\\n  (\:use  [model.transport-map \:as models]))\\r\\n\\r\\n(defn convert-csv [data props]   \\r\\n (let [stuff (map (fn [row] \\r\\n                    (let [item-data (clojure.string/split row \#\\",\\")] \\r\\n                     (models/stock-data row props)))                  \\r\\n(clojure.string/split-lines data 0))]\\r\\n   (remove \#(not\= % (first stuff)))))" "(convert-csv \\n\\"a,b\\na,b\\na,b\\" {\:A \:B})" "(ns utils.csv\\r\\n  (\:use  [model.transport-map \:as models]))\\r\\n\\r\\n(defn convert-csv [data props]   \\r\\n (let [stuff (map (fn [row] \\r\\n                    (let [item-data (clojure.string/split row \#\\",\\")] \\r\\n                     (models/stock-data item-data props)))                  \\r\\n(clojure.string/split-lines data 0))]\\r\\n   (remove \#(not\= % (first stuff)))))" "(convert-csv \\n\\"a,b\\na,b\\na,b\\" {\:A \:B})" "(convert-csv \\n\\"a,b\\\\n\\na,b\\\\n\\na,b\\\\n\\" {\:A \:B})" "(ns utils.csv\\r\\n  (\:use  [model.transport-map \:as models]))\\r\\n\\r\\n(defn convert-csv [data props]   \\r\\n (let [stuff (map (fn [row] \\r\\n                    (let [item-data (clojure.string/split row \#\\",\\")] \\r\\n                     (models/stock-data item-data props)))                  \\r\\n(clojure.string/split-lines data))]\\r\\n   (remove \#(not\= % (first stuff)))))" "(convert-csv \\n\\"a,b\\\\n\\na,b\\\\n\\na,b\\\\n\\" {\:A \:B})" "(ns utils.csv\\r\\n  (\:use  [model.transport-map \:as models]))\\r\\n\\r\\n(defn convert-csv [data props]   \\r\\n (let [stuff (map (fn [row] \\r\\n                    (let [item-data (clojure.string/split row \#\\",\\")] \\r\\n                     (models/stock-data item-data props)))                  \\r\\n(clojure.string/split-lines data))]\\r\\n   (remove \#(not\= % (first stuff) stuff))))" "(convert-csv \\n\\"a,b\\\\n\\na,b\\\\n\\na,b\\\\n\\" {\:A \:B})" "(ns utils.csv\\r\\n  (\:use  [model.transport-map \:as models]))\\r\\n\\r\\n(defn convert-csv [data props]   \\r\\n (let [stuff (map (fn [row] \\r\\n                    (let [item-data (clojure.string/split row \#\\",\\")] \\r\\n                     (models/stock-data item-data props)))                  \\r\\n(clojure.string/split-lines data))]\\r\\n   (remove \#(not\= % (first stuff)) stuff)))" "(convert-csv \\n\\"a,b\\\\n\\na,b\\\\n\\na,b\\\\n\\" {\:A \:B})" "(convert-csv \\n\\"a,b/n\\na,b/n\\na,b/n\\" {\:A \:B})" "(clojure.string/split-lines \\"a,b/n\\r\\n   a,b/n\\r\\n   a,b/n\\")" "(clojure.string/split-lines \\"a,b\\r\\n   a,b\\r\\n   a,b\\")" "(clojure.string/split-lines \\n \\"a,b\\r\\na,b\\r\\na,b\\")" "(get (clojure.string/split-lines \\n      \\"a,b\\r\\na,b\\r\\na,b\\") 1)" "(convert-csv \\n\\"a,b/n\\na,b/n\\na,b/n\\" {\:A \:B})" "(convert-csv \\n\\"a,b/n\\na,b/n\\na,b/n\\" [\:A \:B])" "(ns utils.csv\\r\\n  (\:use  [model.transport-map \:as models]))\\r\\n\\r\\n(defn convert-csv [data props]   \\r\\n (let [stuff (map (fn [row] \\r\\n                    (let [item-data (clojure.string/split row \#\\",\\")] \\r\\n                     (models/stock-data props item-data)))                  \\r\\n(clojure.string/split-lines data))]\\r\\n   (remove \#(not\= % (first stuff)) stuff)))" "(convert-csv \\n\\"a,b/n\\na,b/n\\na,b/n\\" [\:A \:B])" "(convert-csv \\n\\"a,b\\na,b\\na,b\\" [\:A \:B])" "(ns utils.csv\\r\\n  (\:use  [model.transport-map \:as models]))\\r\\n\\r\\n(defn convert-csv [data props]   \\r\\n (let [stuff (map (fn [row] \\r\\n                    (let [item-data (clojure.string/split row \#\\",\\")] \\r\\n                     (models/stock-data props item-data)))                  \\r\\n(clojure.string/split-lines data))]\\r\\n   (filter \#(not\= % (first stuff)) stuff)))" "(convert-csv \\n\\"a,b\\na,b\\na,b\\" [\:A \:B])" "(convert-csv \\n\\"Name1,Name2\\na,b\\na,b\\" [\:A \:B])" "\\n\\n(get-multiple-historical-stock-information [\\"MSFT\\"] \\n                  {\:year \\"1990\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"w\\" nil)" "(defn get-multiple-historical-stock-information  \\r\\n  \\"Gets the historical data information for array of stock names\\"\\r\\n  [stocks-names start-date end-date interval] \\r\\n  (map \\r\\n    (fn [name] \\r\\n      ({name (csv/convert-csv \\r\\n               (get-historical-stock-information-string name start-date end-date interval))})) \\r\\n    stocks-names))" "\\n\\n(get-multiple-historical-stock-information [\\"MSFT\\"] \\n                  {\:year \\"1990\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"w\\" nil)" "\\n\\n(get-multiple-historical-stock-information [\\"MSFT\\"] \\n                  {\:year \\"1990\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"w\\")" "(build-ichart-url \\"MSFT\\" \\n                  {\:year \\"1990\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"w\\")" "(build-ichart-url \\"MSFT\\" \\n                  {\:year \\"2013\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"w\\")" "\\n\\n(get-multiple-historical-stock-information [\\"MSFT\\"] \\n                  {\:year \\"2012\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"w\\")" "\\n(csv/convert-csv \\n  \\"Date,Open,High,Low,Close,Volume,Adj Close\\r\\n2014-08-25,45.40,45.44,44.61,45.43,18371800,45.43\\r\\n2014-08-18,44.94,45.47,44.68,45.15,24064700,45.15\\r\\n2014-08-11,43.26,44.90,43.00,44.79,25119300,44.51\\r\\n2014-08-04,42.97,43.47,42.21,43.20,28887000,42.93\\"\\n  [\:Date \:Open \:High \:Low \:Close \:Volume \:AdjClose])" "\\n\\n(get-historical-stock-information-string [\\"MSFT\\"] \\n                  {\:year \\"2012\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"w\\")" "\\n\\n(get-historical-stock-information-string \\"MSFT\\" \\n                  {\:year \\"2012\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"w\\")" "(csv/convert-csv \\r\\n               (get-historical-stock-information-string \\"MSFT\\" \\r\\n                     {\:year \\"2013\\" \:month \\"00\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"w\\")\\r\\n               [\:Date \:Open \:High \:Low \:Close \:Volume \:AdjClose])" "\\n\\n(get-multiple-historical-stock-information [\\"MSFT\\"] \\n                  {\:year \\"2012\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"w\\")" "\\n\\n(get-multiple-historical-stock-information [\\"MSFT\\"] \\n                  {\:year \\"2012\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"m\\")" "\\n\\n(get-multiple-historical-stock-information [\\"MSFT\\" \\"YHOO\\"] \\n                  {\:year \\"2012\\" \:month \\"00\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"m\\")" "\\n\\n(get-multiple-historical-stock-information [\\"MSFT\\" \\"YHOO\\"] \\n                  {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"m\\")" "(defn get-single-historical-stock-information  \\r\\n  \\"Gets the historical data information for array of stock names\\"\\r\\n  [stock-name start-date end-date interval] \\r\\n   (csv/convert-csv \\r\\n              (get-historical-stock-information-string stock-name start-date end-date interval)\\r\\n              [\:Date \:Open \:High \:Low \:Close \:Volume \:AdjClose]))" "\\n\\n(get-single-historical-stock-information \\"MSFT\\" \\n                  {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"m\\")" " (map \#(\:Volumn %) (get-single-historical-stock-information \\"MSFT\\" \\r\\n                     {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"m\\"))" " (map \\n   \#(\\"MSFT\\" %) \\n   (get-single-historical-stock-information \\"MSFT\\" \\r\\n                     {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"m\\"))" " (map \\n   \#(get % \\"MSFT\\") \\n   (get-single-historical-stock-information \\"MSFT\\" \\r\\n                     {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"m\\"))" " (map \\n   \#(\:data \\"MSFT\\") \\n   (get-single-historical-stock-information \\"MSFT\\" \\r\\n                     {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"m\\"))" "\\n\\n(get-multiple-historical-stock-information [\\"MSFT\\" \\"YHOO\\"] \\n                  {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\n                  nil\\n                  \\"m\\")" " (map \\n   \#(\:data %) \\n   (get-single-historical-stock-information \\"MSFT\\" \\r\\n                     {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"m\\"))" " (map \\n   (fn [d] d) \\n   (get-single-historical-stock-information \\"MSFT\\" \\r\\n                     {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"m\\"))" "(defn get-multiple-historical-stock-information  \\r\\n  \\"Gets the historical data information for array of stock names\\"\\r\\n  [stocks-names start-date end-date interval] \\r\\n (vector (map \\r\\n         (fn [name] \\r\\n           {\:name name \:data (csv/convert-csv \\r\\n                               (get-historical-stock-information-string name start-date end-date interval)\\r\\n                               [\:Date \:Open \:High \:Low \:Close \:Volume \:AdjClose])}) \\r\\n         stocks-names)))" " (map \\n   (fn [d] d) \\n   (get-single-historical-stock-information \\"MSFT\\" \\r\\n                     {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"m\\"))" " \\n   (get-single-historical-stock-information \\"MSFT\\" \\r\\n                     {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"m\\")" " \\n   (get-multiple-historical-stock-information \\"MSFT\\" \\r\\n                     {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"m\\")" " \\n   (get-single-historical-stock-information \\"MSFT\\" \\r\\n                     {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"m\\")" " \\n (calculate-nmf  \\n   (get-multiple-historical-stock-information [\\"MSFT\\"] \\r\\n                     {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"m\\"))" "(defn calculate-nmf [stocks-data]\\r\\n  (let [\\r\\n        data(map \\r\\n              \#(\:Volumn %) stocks-data)\\r\\n      \\r\\n        ff (fn [item] \\r\\n             (let [data (\:data item )]\\r\\n             {\:columns \\r\\n              (map \\r\\n              \#(\:Date %) data)  \\r\\n              \:data \\r\\n               (map \\r\\n              \#(\:Volume %) data) }))\\r\\n        tables (map ff stocks-data)]))" " \\n (calculate-nmf  \\n   (get-multiple-historical-stock-information [\\"MSFT\\"] \\r\\n                     {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"m\\"))" "(defn calculate-nmf [stocks-data]\\r\\n  (let [     \\r\\n        ff (fn [item] \\r\\n             (let [data (\:data item )]\\r\\n             {\:columns \\r\\n              (map \\r\\n              \#(\:Date %) data)  \\r\\n              \:data \\r\\n               (map \\r\\n              \#(\:Volume %) data) }))]\\r\\n    (map ff stocks-data)))" " \\n (calculate-nmf  \\n   (get-multiple-historical-stock-information [\\"MSFT\\"] \\r\\n                     {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"m\\"))" " (get-multiple-historical-stock-information [\\"MSFT\\"] \\r\\n                        {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                        nil\\r\\n                        \\"m\\")" " \\n (calculate-nmf  \\n  (apply (get-multiple-historical-stock-information [\\"MSFT\\"] \\r\\n                     {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"m\\")))" " \\n (calculate-nmf  \\n  (doall (get-multiple-historical-stock-information [\\"MSFT\\"] \\r\\n                     {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                     nil\\r\\n                     \\"m\\")))" " (doall (get-multiple-historical-stock-information [\\"MSFT\\"] \\r\\n                        {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                        nil\\r\\n                        \\"m\\"))" "(let [data (get-multiple-historical-stock-information [\\"MSFT\\"] \\r\\n                           {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                           nil\\r\\n                           \\"m\\")]\\n  (calculate-nmf data))" "(let [data (vector (get-multiple-historical-stock-information [\\"MSFT\\"] \\r\\n                           {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                           nil\\r\\n                           \\"m\\"))]\\n  (calculate-nmf data))" "(let [data \#(vector (get-multiple-historical-stock-information [\\"MSFT\\"] \\r\\n                           {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                           nil\\r\\n                           \\"m\\"))]\\n  (calculate-nmf data))" "(let [data \#(get-multiple-historical-stock-information [\\"MSFT\\"] \\r\\n                           {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                           nil\\r\\n                           \\"m\\")]\\n  (calculate-nmf data))" " (get-multiple-historical-stock-information [\\"MSFT\\"] \\r\\n                        {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                        nil\\r\\n                        \\"m\\")" "(let [data \#(get-multiple-historical-stock-information [\\"MSFT\\"] \\r\\n                           {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                           nil\\r\\n                           \\"m\\")]\\n  (calculate-nmf data))" "(defn get-multiple-historical-stock-information  \\r\\n  \\"Gets the historical data information for array of stock names\\"\\r\\n  [stocks-names start-date end-date interval] \\r\\n (map \\r\\n (fn [name] \\r\\n   {\:name name \:data (csv/convert-csv \\r\\n                      (get-historical-stock-information-string name start-date end-date interval)\\r\\n                      [\:Date \:Open \:High \:Low \:Close \:Volume \:AdjClose])}) \\r\\n stocks-names))" "(db/get-multiple-historical-stock-information [\\"MSFT\\"] \\r\\n                           {\:year \\"2014\\" \:month \\"05\\" \:day \\"1\\"}  \\r\\n                           nil\\r\\n                           \\"m\\")" "(parse-number \\"1\\")" "(read-string \\"1\\")" "(def stock-data-model\\r\\n  [\:Date \:Open \:High \:Low \:Close \:Volume \:AdjClose])" "\\n(try (db-do-commands db \\r\\n(create-table-ddl \\"Test-Table\\" \\r\\n    [\:date \:text] \\r\\n    [\:url \:text] \\r\\n    [\:title \:text] \\r\\n     [\:body \:text])) \\r\\n        (catch Exception e (println e)))" "(jdbc/db-do-commands db-spec\\r\\n                     (jdbc/create-table-ddl \:fruit\\r\\n                                            [\:name \\"varchar(32)\\"]\\r\\n                                            [\:appearance \\"varchar(32)\\"]\\r\\n                                            [\:cost \:int]\\r\\n                                            [\:grade \:real]))\\r\\n(jdbc/db-do-commands db-spec \\"CREATE INDEX name_ix ON fruit ( name )\\")" "(jdb-do-commands database\\r\\n                     (create-table-ddl \:fruit\\r\\n                                            [\:name \\"varchar(32)\\"]\\r\\n                                            [\:appearance \\"varchar(32)\\"]\\r\\n                                            [\:cost \:int]\\r\\n                                            [\:grade \:real]))\\r\\n(db-do-commands database \\"CREATE INDEX name_ix ON fruit ( name )\\")" "(jdbc/db-do-commands database\\r\\n                     (jdbc/create-table-ddl \:fruit\\r\\n                                            [\:name \\"varchar(32)\\"]\\r\\n                                            [\:appearance \\"varchar(32)\\"]\\r\\n                                            [\:cost \:int]\\r\\n                                            [\:grade \:real]))\\r\\n(jdbc/db-do-commands database \\"CREATE INDEX name_ix ON fruit ( name )\\")" "(try (db-do-commands database \\r\\n                        (create-table-ddl \:news \\r\\n                                          [\:date \:text] \\r\\n                                          [\:url \:text] \\r\\n                                          [\:title \:text] \\r\\n                                          [\:body \:text])) \\r\\n        (catch Exception e (println e)))" "(try (jdbc/db-do-commands database \\r\\n                        (jdbc/create-table-ddl \:news \\r\\n                                          [\:date \:text] \\r\\n                                          [\:url \:text] \\r\\n                                          [\:title \:text] \\r\\n                                          [\:body \:text])) \\r\\n        (catch Exception e (println e)))" "(with-connection database\\r\\n   (sql/create-table\\r\\n   \:nominees\\r\\n   [\:id \:integer \\"PRIMARY KEY\\"]\\r\\n   [\:year \:integer]\\r\\n   [\:title \\"varchar(64)\\"]\\r\\n   [\:author \\"varchar(32)\\"]\\r\\n   [\:winner \\"tinyint\\"]\\r\\n   [\:read_it \\"tinyint\\"]\\r\\n   [\:own_it \\"tinyint\\"]\\r\\n   [\:want_it \\"tinyint\\"]))" "(with-connection database\\r\\n   (create-table\\r\\n   \:nominees\\r\\n   [\:id \:integer \\"PRIMARY KEY\\"]\\r\\n   [\:year \:integer]\\r\\n   [\:title \\"varchar(64)\\"]\\r\\n   [\:author \\"varchar(32)\\"]\\r\\n   [\:winner \\"tinyint\\"]\\r\\n   [\:read_it \\"tinyint\\"]\\r\\n   [\:own_it \\"tinyint\\"]\\r\\n   [\:want_it \\"tinyint\\"]))" "(with-connection database\\r\\n   (create-table\\r\\n   \:nominees\\r\\n   [\:id \:integer \\"PRIMARY KEY\\"]\\r\\n   [\:year \:integer]\\r\\n   [\:title \\"varchar(64)\\"]\\r\\n   [\:author \\"varchar(32)\\"]\\r\\n   [\:winner \\"tinyint\\"]\\r\\n   [\:read_it \\"tinyint\\"]\\r\\n   [\:own_it \\"tinyint\\"]\\r\\n   ))" "(drop-table \:nominees)" "(with-connection database\\r\\n   (drop-table\\r\\n   \:nominees\\r\\n  \\r\\n   ))" "(with-connection database\\r\\n   (create-table\\r\\n   \:nominees\\r\\n   [\:id \:integer \\"PRIMARY KEY\\"]\\r\\n   [\:year \:integer \\"INDEX\\"]\\r\\n   [\:title \\"varchar(64)\\"]\\r\\n   [\:author \\"varchar(32)\\"]\\r\\n   [\:winner \\"tinyint\\"]\\r\\n   [\:read_it \\"tinyint\\"]\\r\\n   [\:own_it \\"tinyint\\"]\\r\\n   ))" "(with-connection database\\r\\n   (create-table\\r\\n   \:nominees\\r\\n   [\:id \:integer \\"PRIMARY KEY\\"]\\r\\n   [\:year \:integer \\"PRIMARY KEY\\"]\\r\\n   [\:title \\"varchar(64)\\"]\\r\\n   [\:author \\"varchar(32)\\"]\\r\\n   [\:winner \\"tinyint\\"]\\r\\n   [\:read_it \\"tinyint\\"]\\r\\n   [\:own_it \\"tinyint\\"]\\r\\n   ))" "(with-connection database\\r\\n   (create-table\\r\\n   \:nominees\\r\\n   [\:id \:real \\"PRIMARY KEY\\"]\\r\\n   [\:year \:integer ]\\r\\n   \\r\\n   ))" "(defn- read-date [d] d)\\r\\n(def stock-data-model\\r\\n  [[\:Date read-date] [\:Open read-string] [\:High read-string] [\:Low read-string] [\:Close read-string] [\:Volume read-string] [\:AdjClose read-string]])\\r\\n\\r\\n(defn- build-ichart-url\\r\\n   [stock-name start-date end-date interval] \\r\\n   (str \\"http\://ichart.finance.yahoo.com/table.csv?\\" \\r\\n        \\"s\=\\" stock-name\\r\\n        (if (nil? start-date) \\"\\" \\r\\n          (str \\"&c\=\\" (\:year start-date) \\r\\n               \\"&a\=\\" (\:month start-date)\\r\\n               \\"&b\=\\" (\:day start-date)))\\r\\n        (if (nil? end-date) \\"\\" \\r\\n          (str \\"&d\=\\" (\:month end-date) \\r\\n               \\"&e\=\\" (\:day end-date)\\r\\n               \\"&f\=\\" (\:year end-date)))\\r\\n         (if (nil? interval) \\"\\" \\r\\n          (str \\"&g\=\\" interval))))\\r\\n\\r\\n(defn- get-historical-stock-information-string  \\r\\n  [stock-name start-date end-date interval] \\r\\n  (with-open [client (http/create-client)]\\r\\n  (let [response (http/GET client (build-ichart-url stock-name start-date end-date interval))]\\r\\n    (-> response \\r\\n      http/await\\r\\n      http/string ))))\\r\\n\\r\\n(defn get-single-historical-stock-information  \\r\\n  \\"Gets the historical data information for array of stock names\\"\\r\\n  [stock-name start-date end-date interval] \\r\\n   (csv/convert-csv \\r\\n              (get-historical-stock-information-string stock-name start-date end-date interval)\\r\\n              stock-data-model))\\r\\n\\r\\n(defn get-multiple-historical-stock-information  \\r\\n  \\"Gets the historical data information for array of stock names\\"\\r\\n  [stocks-names start-date end-date interval] \\r\\n (map \\r\\n (fn [name] \\r\\n   {\:name name \:data (csv/convert-csv \\r\\n                      (get-historical-stock-information-string name start-date end-date interval)\\r\\n                      stock-data-model)}) \\r\\n stocks-names))\\r\\n\\r\\n(defn- create-portfolio-table [portfolio-id]\\r\\n  (with-connection database\\r\\n      (create-table \\r\\n       (str \\"PortfolioFeatures_\\" portfolio-id\\r\\n            [\:Feature \\"varchar(64)\\" ]\\r\\n             [\:Type \\"varchar(64)\\"]\\r\\n             [\:Name \\"varchar(64)\\"]\\r\\n             [\:Value \:real]))))\\r\\n\\r\\n(defn- create-rows [rows w columns h]\\r\\n (let [\\r\\n       rows-data (for [i (range (count rows)) j (range (count (first w)))]\\r\\n                   {\:Feature (str \\"F\\" j)\\r\\n                    \:Type \\"R\\"\\r\\n                    \:Name  rows i\\r\\n                    \:Value (get (get w i) j)})\\r\\n       column-data (for [i (range (count columns)) j (range (count h))]\\r\\n                   {\:Feature (str \\"F\\" j)\\r\\n                    \:Type \\"C\\"\\r\\n                    \:Name (get columns i)\\r\\n                    \:Value (get (get h j) i)})\\r\\n       ]\\r\\n   [rows-data column-data]))     \\r\\n \\r\\n\\r\\n(defn save-features \\r\\n  [portfolio-id rows columns w h] \\r\\n  (create-rows rows w columns h))" "'(\\"s\\" \\"c\\")" "(get (\\"s\\" \\"c\\") 1)" "(get [\\"s\\" \\"c\\"] 1)" "(get '(\\"s\\" \\"c\\") 1)" "(nth '(\\"s\\" \\"c\\") 1)" "(with-connection database\\r\\n      (do-commands (str \\"drop table if exists [AAA]\\")))" "(use '(clojure.java.jdbc))" "(with-connection database\\r\\n      (do-commands (str \\"drop table if exists [AAA]\\")))" "(defn comm []\\n   (with-connection database\\r\\n         (do-commands (str \\"drop table if exists [AAA]\\"))))" "database" "(with-connection database\\r\\n      (do-commands (str \\"drop table if exists [\\" table-name \\"]\\")))" "comm" "(comm)" "(defn get-stock-data-by-id\\r\\n  [params stock-name start-date end-date interval]\\r\\n  (db/get-single-historical-stock-information \\r\\n    (\:stock-name params) \\r\\n    (\:start-date params) \\r\\n    (\:end-date params) \\r\\n    (\:interval params)))" "\\n(get-stock-data-by-id {\:stock-name \\"MSFT\\" \\r\\n                        \:start-date nil;(\:start-date (get params \\"startDate\\"))\\r\\n                        \:end-date nil;(\:end-date (get params \\"endDate\\"))\\r\\n                        \:interval nil;(\:interval (get params \\"interval\\"))\\r\\n                        })" "\\n(f/parse built-in-formatter \\"20100311\\")" "\\n(f/parse built-in-formatter \\"2010-03-11\\")" "(def custom-formatter (f/formatter \\"yyyy-MM-dd\\"))" "\\n(f/parse custom-formatter \\"2010-03-11\\")" "\\n(format-yahoo-time \\n  (f/parse custom-formatter \\"2010-03-11\\"))" "(get-portfolio-stock-names 1)" "(require 'clojure.tools.trace)" "(def fields {\\r\\n       \:Ask                                 \\"a\\" \\r\\n       \:DividendYield                       \\"y\\"\\r\\n       \:Bid                                 \\"b\\"\\r\\n       \:DividendPerShare                    \\"d\\"\\r\\n       \:AskRealtime                         \\"b2\\"\\r\\n       \:DividendPayDate                     \\"r1\\" \\r\\n       \:BidRealtime                         \\"b3\\" \\r\\n       \:ExDividend                          \\"q\\"\\r\\n       ;//Date \\r\\n       \:PreviousClose                       \\"p\\"  \\r\\n       \:OpenDate                            \\"o\\"\\r\\n       \:Change                              \\"c1\\" \\r\\n       \:LastTradeDate                       \\"d1\\" \\r\\n       \:ChangeAndPercentChange              \\"c\\"\\r\\n       \:TradeDate                           \\"d2\\" \\r\\n       \:ChangeRealtime                      \\"c6\\" \\r\\n       \:LastTradeTime                       \\"t1\\"\\r\\n       \:ChangePercentRealtime               \\"k2\\"  \\r\\n       \:ChangeInPercent                     \\"p2\\"  \\r\\n       ;//Averages \\r\\n       \:AfterHoursChangeRealtime            \\"c8\\"\\r\\n       \:ChangeFrom200DayMovingAverage       \\"m5\\"\\r\\n       \:Commission                          \\"c3\\"\\r\\n       \:PercentChangeFrom200DayMovingAverage\\"m6\\"\\r\\n       \:DaysLow                             \\"g\\"\\r\\n       \:ChangeFrom50DayMovingAverage        \\"m7\\"\\r\\n       \:DaysHigh                            \\"h\\"\\r\\n       \:PercentChangeFrom50DayMovingAverage \\"m8\\"\\r\\n       \:LastTradeRealtimeWithTime           \\"k1\\"\\r\\n       \:DayMovingAverage50                  \\"m3\\"\\r\\n       \:LastTradeWithTime                   \\"l\\"\\r\\n       \:DayMovingAverage200                 \\"m4\\"\\r\\n       \:LastTradePriceOnly                  \\"l1\\"\\r\\n       \:TargetPrice1yr                      \\"t8\\"\\r\\n       ;//Misc                              \\r\\n       \:DaysValueChange                     \\"w1\\"\\r\\n       \:HoldingsGainPercent                 \\"g1\\"\\r\\n       \:DaysValueChangeRealtime             \\"w4\\"\\r\\n       \:AnnualizedGain                      \\"g3\\"\\r\\n       \:PricePaid                           \\"p1\\"\\r\\n       \:HoldingsGain                        \\"g4\\"\\r\\n       \:DaysRange                           \\"m \\"\\r\\n       \:HoldingsGainPercentRealtime         \\"g5\\"\\r\\n       \:DaysRangeRealtime                   \\"m2\\"\\r\\n       \:HoldingsGainRealtime                \\"g6\\"\\r\\n       ;//52  WeekPricingSymbolInfo \\r\\n       \:WeekHigh52                          \\"k\\" \\r\\n       \:MoreInfo                            \\"v\\" \\r\\n       \:WeekLow52                           \\"j\\" \\r\\n       \:MarketCapitalization                \\"j1\\" \\r\\n       \:ChangeFrom52WeekLow                 \\"j5\\" \\r\\n       \:MarketCapRealtime                   \\"j3\\" \\r\\n       \:ChangeFrom52WeekHigh                \\"k4\\" \\r\\n       \:FloatShares                         \\"f6\\" \\r\\n       \:PercentChangeFrom52WeekLow          \\"j6\\" \\r\\n       \:Name                                \\"n\\" \\r\\n       \:PercentChangeFrom52WeekHigh         \\"k5\\" \\r\\n       \:Notes                               \\"n4\\"\\r\\n       \:WeekRange52                         \\"w\\"\\r\\n       \:Symbol                              \\"s\\"\\r\\n       \:SharesOwned                         \\"s1\\" \\r\\n       \:StockExchange                       \\"x\\" \\r\\n       \:SharesOutstanding                   \\"j2\\" \\r\\n       \://Volume \\r\\n       \:Volume                              \\"v\\" \\r\\n       \:AskSize                             \\"a5\\" \\r\\n       \:BidSizeMisc                         \\"b6\\"\\r\\n       \:LastTradeSize                       \\"k3\\"\\r\\n       \:TickerTrend                         \\"t7\\" \\r\\n       \:AverageDailyVolume                  \\"a2\\" \\r\\n       \:TradeLinks                          \\"t6\\" \\r\\n       \:OrderBookRealtime                   \\"i5\\" \\r\\n       ;//Ratios \\r\\n       \:HighLimit                           \\"l2\\"\\r\\n       \:EarningsPerShare                    \\"e\\"\\r\\n       \:LowLimit                            \\"l3\\"\\r\\n       \:EPSEstimateCurrentYear              \\"e7\\"\\r\\n       \:HoldingsValue                       \\"v1\\"\\r\\n       \:EPSEstimateNextYear                 \\"e8\\"\\r\\n       \:HoldingsValueRealtime               \\"v7\\"\\r\\n       \:EPSEstimateNextQuarter              \\"e9\\"\\r\\n       \:Revenue                             \\"s6\\"\\r\\n       \:BookValue                           \\"b4\\"\\r\\n       \:EBITDA                              \\"j4\\"\\r\\n       \:PriceSales                          \\"p5\\"\\r\\n       \:PriceBook                           \\"p6\\"\\r\\n       \:PERatio                             \\"r\\"\\r\\n       \:PERatioRealtime                     \\"r2\\"\\r\\n       \:PEGRatio                            \\"r5\\"\\r\\n       \:PriceEPSEstimateCurrentYear         \\"r6\\"\\r\\n       \:PriceEPSEstimateNextYear            \\"r7\\"\\r\\n       \:ShortRatio                          \\"s7\\"\\r\\n    })" "(build-all-stock-data-url\\n  \\"MSFT\\")" "(build-all-stock-data-url \\"MSFT\\")" " (get-long-stock-data-string \\"MSFT\\")" "(db/get-stock-starts-top \\"M\\" 5)" "(get-stock-starts-top (\:value \\"M\\") (\:take 5))" "(get-stock-starts-top {(\:value \\"M\\") (\:take 5)})" "(get-stock-starts-top {\:value \\"M\\" \:take 5})" "(get-short-stock-data [\\"MSFT\\"])" " (map (fn [s] (clojure.string/replace \\"^\\" \\"%5\\")) [\\"l\\"])" " (map (fn [s] (clojure.string/replace \\"hg\\" \\"^\\" \\"%5\\")) [\\"l\\"])" "(get-short-stock-data [\\"MSFT\\"])" "(get-short-stock-data [\\"^IXIC\\"])" "(get-short-stock-data [\\"^DJI\\"])" "(clojure.string/replace \\"^DJI\\" \\"^\\" \\"%5\\")" "(map (fn [s] (clojure.string/replace s \\"^\\" \\"%5\\")) [\\"^DJI\\"])" "(defn-  build-short-stock-data-url\\r\\n   [stocks-names] \\r\\n   (str \\"http\://download.finance.yahoo.com/d/quotes.csv?\\" \\r\\n        \\"s\=\\" (clojure.string/join \\"+\\" (map (fn [s] (clojure.string/replace s \\"^\\" \\"%5\\")) stocks-names) )\\r\\n         \\"&f\=snopc1p2x\\" ))" "(build-short-stock-data-url [\\"^DJI\\" \\"^ABC\\"])" "(get-short-stock-data [\\"^DJI\\"])" "(build-short-stock-data-url [\\"^DJI\\"])" "(build-short-stock-data-url [\\"^IXIC\\"])" "(get-short-stock-data [\\"^IXIC\\"])" "(do \\n  (let [a  (println \\"\\")] \\"\\")\\n  )" "(do \\n  (let [a  (println \\"asdasd\\")] \\"\\")\\n  )" "(calculate-nmf \\n  {\\n   \:portfolio-id 1\\n   \:start-date nil\\n   \:end-date nil\\n   \:interval nil\\n   \:nf 5\\n   \:iter 50\\n   })" "(calculate-nmf \\n  {\\n   \:portfolio-id 1\\n   \:start-date nil\\n   \:end-date nil\\n   \:interval nil\\n   \:nf 5\\n   \:iter 2\\n   })" "(calculate-nmf \\n  {\\n   \:portfolio-id 1\\n   \:start-date {\:day 1 \:month 1 \:year 2010}\\n   \:end-date nil\\n   \:interval nil\\n   \:nf 5\\n   \:iter 2\\n   })" "(calculate-nmf \\n  {\\n   \:portfolio-id 1\\n   \:start-date {\:day 1 \:month 7 \:year 2014}\\n   \:end-date nil\\n   \:interval nil\\n   \:nf 5\\n   \:iter 2\\n   })" "(calculate-nmf \\n  {\\n   \:portfolio-id 2\\n   \:start-date nil\\n   \:end-date nil\\n   \:interval nil\\n   \:nf 5\\n   \:iter 2\\n   })" "(calculate-nmf \\n  {\\n   \:portfolio-id 1\\n   \:start-date nil\\n   \:end-date nil\\n   \:interval nil\\n   \:nf 5\\n   \:iter 2\\n   })" "(type \\"\\")" "(\= \\n  (type \\"\\") \\n  \\"java.lang.String\\")" "(\= \\n  (type \\"\\") \\n  java.lang.String)" "(calculate-nmf \\n  {\:portfolio-id 2\\n   \:start-date \\n   {\\n    \:year 2000\\n    \:month 1\\n    \:day 1\\n    }\\n   \:end-date nil\\n   \:interval nil\\n   \:nf 4\\n   \:iter 10})" "(calculate-nmf \\n  {\:portfolio-id 2\\n   \:start-date \\n   {\\n    \:year 2014\\n    \:month 1\\n    \:day 1\\n    }\\n   \:end-date nil\\n   \:interval nil\\n   \:nf 4\\n   \:iter 10})" "(calculate-nmf \\n  {\:portfolio-id 2\\n   \:start-date \\n   {\\n    \:year 2000\\n    \:month 1\\n    \:day 1\\n    }\\n   \:end-date nil\\n   \:interval nil\\n   \:nf 4\\n   \:iter 10})" "(calculate-nmf \\n  {\:portfolio-id 2\\n   \:start-date \\n   {\\n    \:year 2000\\n    \:month 1\\n    \:day 1\\n    }\\n   \:end-date nil\\n   \:interval \\"w\\"\\n   \:nf 4\\n   \:iter 10})" "(with-connection database\\r\\n        (do-commands \\n          \\"select 1\\"\\n          [\\"select 2\\"]))" "(with-connection database\\r\\n        (do-commands \\n          \\n          [\\"select 2\\"]))" "(with-connection database\\r\\n        (do-commands \\n          \\n          '[\\"select 2\\"]))" "(with-connection database\\r\\n        (do (do-commands \\n          \\n              '[\\"select 2\\"])))" "(with-connection database\\r\\n        (do (do-commands \\n          \\n              \\"select 2\\")))" "(with-connection database\\r\\n       ( do-commands \\n          \\n              \\"select 'F4','R','YHOO',20.151948440732916 \\"))" "(calculate-nmf \\n  {\:portfolio-id 2\\n   \:start-date \\n   {\\n    \:year 2000\\n    \:month 1\\n    \:day 1\\n    }\\n   \:end-date nil\\n   \:interval \\"w\\"\\n   \:nf 4\\n   \:iter 10})" "(with-connection database\\r\\n        (do\\r\\n         (do-commands \\r\\n         \\"select 1,2\\"              \\r\\n         \\"select 1,2\\"  )\\n         ( table-name (rows))))" "(with-connection database\\r\\n        (do\\r\\n         (do-commands \\r\\n         \\"select 1,2\\"              \\r\\n         \\"select 1,2\\"  )\\n         (do-commands \\r\\n         \\"select 1,2\\"              \\r\\n         \\"select 1,2\\"  )))" "(with-connection database\\r\\n        (do\\r\\n         (with-query-results \\r\\n           rs           \\r\\n         [\\"select 1,2\\"] rs )\\n         (with-query-results rs\\r\\n         [\\"select 1,2\\"]   rs      )))" "(calculate-nmf \\n  {\:portfolio-id 2\\n   \:start-date \\n   {\\n    \:year 2014\\n    \:month 6\\n    \:day 1\\n    }\\n   \:end-date nil\\n   \:interval \\"w\\"\\n   \:nf 4\\n   \:iter 10})" " (let [table-name \\n       (str \\"PortfolioFeatures_\\" 2)\\r\\n        rows [{\:Feature \\"1\\"\\r\\n                  \:Type \\"1\\"\\r\\n                  \:Name \\"1\\"\\r\\n                  \:Value \\"1\\" }]\\r\\n       table\\r\\n       (with-connection database\\r\\n        (do\\r\\n         (do-commands \\r\\n         (str \\"drop table if exists [\\" table-name \\"]\\")              \\r\\n         (str \\r\\n           \\"create table if not exists [\\" table-name \\"] (Feature text,Type text,Name text,Value real)\\"))\\r\\n          (insert-records table-name rows)))\\r\\n         ]" " (let [table-name \\n       (str \\"PortfolioFeatures_\\" 2)\\r\\n        rows [{\:Feature \\"1\\"\\r\\n                  \:Type \\"1\\"\\r\\n                  \:Name \\"1\\"\\r\\n                  \:Value \\"1\\" }]\\r\\n       table\\r\\n       (with-connection database\\r\\n        (do\\r\\n         (do-commands \\r\\n         (str \\"drop table if exists [\\" table-name \\"]\\")              \\r\\n         (str \\r\\n           \\"create table if not exists [\\" table-name \\"] (Feature text,Type text,Name text,Value real)\\"))\\r\\n          (insert-records table-name rows)))\\r\\n         ] rows)" " (let [table-name \\n       (str \\"PortfolioFeatures_\\" 2)\\r\\n        rows '({\:Feature \\"1\\"\\r\\n                  \:Type \\"1\\"\\r\\n                  \:Name \\"1\\"\\r\\n                  \:Value \\"1\\" })\\r\\n       table\\r\\n       (with-connection database\\r\\n        (do\\r\\n         (do-commands \\r\\n         (str \\"drop table if exists [\\" table-name \\"]\\")              \\r\\n         (str \\r\\n           \\"create table if not exists [\\" table-name \\"] (Feature text,Type text,Name text,Value real)\\"))\\r\\n          (insert-records table-name rows)))\\r\\n         ] rows)" " (let [table-name \\n       (str \\"PortfolioFeatures_\\" 2)\\r\\n        rows '{{\:Feature \\"1\\"\\r\\n                  \:Type \\"1\\"\\r\\n                  \:Name \\"1\\"\\r\\n                  \:Value \\"1\\" }}\\r\\n       table\\r\\n       (with-connection database\\r\\n        (do\\r\\n         (do-commands \\r\\n         (str \\"drop table if exists [\\" table-name \\"]\\")              \\r\\n         (str \\r\\n           \\"create table if not exists [\\" table-name \\"] (Feature text,Type text,Name text,Value real)\\"))\\r\\n          (insert-records table-name rows)))\\r\\n         ] rows)" " (let [table-name \\n       (str \\"PortfolioFeatures_\\" 2)\\r\\n        rows '{{\:Feature \\"1\\"\\r\\n                  \:Type \\"1\\"\\r\\n                  \:Name \\"1\\"\\r\\n                  \:Value \\"1\\" }}\\r\\n       table\\r\\n       (with-connection database\\r\\n        (do\\r\\n         (do-commands \\r\\n         (str \\"drop table if exists [\\" table-name \\"]\\")              \\r\\n         (str \\r\\n           \\"create table if not exists [\\" table-name \\"] (Feature text,Type text,Name text,Value real)\\"))\\r\\n          (insert-records table-name {\:Feature \\"1\\"\\r\\n                  \:Type \\"1\\"\\r\\n                  \:Name \\"1\\"\\r\\n                  \:Value \\"1\\" })))\\r\\n         ] rows)" " (let [table-name \\n       (str \\"PortfolioFeatures_\\" 2)\\r\\n        rows {\:Feature \\"1\\"\\r\\n                  \:Type \\"1\\"\\r\\n                  \:Name \\"1\\"\\r\\n                  \:Value \\"1\\" }\\r\\n       table\\r\\n       (with-connection database\\r\\n        (do\\r\\n         (do-commands \\r\\n         (str \\"drop table if exists [\\" table-name \\"]\\")              \\r\\n         (str \\r\\n           \\"create table if not exists [\\" table-name \\"] (Feature text,Type text,Name text,Value real)\\"))\\r\\n          (insert-records table-name {\:Feature \\"1\\"\\r\\n                  \:Type \\"1\\"\\r\\n                  \:Name \\"1\\"\\r\\n                  \:Value \\"1\\" })))\\r\\n         ] rows)" " (let [table-name \\n       (str \\"PortfolioFeatures_\\" 2)\\r\\n        rows [{\:Feature \\"1\\"\\r\\n                  \:Type \\"1\\"\\r\\n                  \:Name \\"1\\"\\r\\n                  \:Value \\"1\\" }]\\r\\n       table\\r\\n       (with-connection database\\r\\n        (do\\r\\n         (do-commands \\r\\n         (str \\"drop table if exists [\\" table-name \\"]\\")              \\r\\n         (str \\r\\n           \\"create table if not exists [\\" table-name \\"] (Feature text,Type text,Name text,Value real)\\"))\\r\\n          (insert-records table-name rows)))\\r\\n         ] rows)" "(calculate-nmf \\n  {\:portfolio-id 2\\n   \:start-date \\n   {\\n    \:year 2014\\n    \:month 6\\n    \:day 1\\n    }\\n   \:end-date nil\\n   \:interval \\"w\\"\\n   \:nf 4\\n   \:iter 10})" "(calculate-nmf \\n  {\:portfolio-id 2\\n   \:start-date \\n   {\\n    \:year 2010\\n    \:month 6\\n    \:day 1\\n    }\\n   \:end-date nil\\n   \:interval \\"w\\"\\n   \:nf 4\\n   \:iter 10})" "(calculate-nmf \\n  {\:portfolio-id 1\\n   \:start-date \\n   {\\n    \:year 2010\\n    \:month 6\\n    \:day 1\\n    }\\n   \:end-date nil\\n   \:interval \\"w\\"\\n   \:nf 4\\n   \:iter 10})" "(calculate-nmf \\n  {\:portfolio-id 1\\n   \:start-date \\n   {\\n    \:year 2010\\n    \:month 6\\n    \:day 1\\n    }\\n   \:end-date nil\\n   \:interval \\"w\\"\\n   \:nf 2\\n   \:iter 10})" "(calculate-nmf \\n  {\:portfolio-id 2\\n   \:start-date \\n   {\\n    \:year 2010\\n    \:month 6\\n    \:day 1\\n    }\\n   \:end-date nil\\n   \:interval \\"w\\"\\n   \:nf 2\\n   \:iter 10})" "(calculate-nmf \\n  {\:portfolio-id 1\\n   \:start-date \\n   {\\n    \:year 2014\\n    \:month 6\\n    \:day 1\\n    }\\n   \:end-date nil\\n   \:interval \\"w\\"\\n   \:nf 2\\n   \:iter 10})" "(calculate-nmf \\n  {\:portfolio-id 2\\n   \:start-date \\n   {\\n    \:year 2014\\n    \:month 6\\n    \:day 1\\n    }\\n   \:end-date nil\\n   \:interval \\"w\\"\\n   \:nf 2\\n   \:iter 10})" " (with-connection database\\r\\n         ;(do\\r\\n           (do-commands \\r\\n             (str \\"drop table if exists [\\" table-name \\"]\\")              \\r\\n             (str \\"create table if not exists [\\" table-name \\"] (Feature text,Type text,Name text,Value real)\\"))" " (with-connection database\\r\\n         ;(do\\r\\n           (do-commands \\r\\n             (str \\"drop table if exists [\\" table-name \\"]\\")              \\r\\n             (str \\"create table if not exists [\\" table-name \\"] (Feature text,Type text,Name text,Value real)\\"))\\n           )" " (with-connection database\\r\\n         ;(do\\r\\n           (do-commands \\r\\n             (str \\"drop table if exists [\\" \\"1\\" \\"]\\")              \\r\\n             (str \\"create table if not exists [\\" \\"1\\" \\"] (Feature text,Type text,Name text,Value real)\\"))\\n           )" "(calculate-nmf \\n  {\:portfolio-id 2\\n   \:start-date \\n   {\\n    \:year 2014\\n    \:month 6\\n    \:day 1\\n    }\\n   \:end-date nil\\n   \:interval \\"w\\"\\n   \:nf 2\\n   \:iter 10})" "(calculate-nmf \\n  {\:portfolio-id 1\\n   \:start-date \\n   {\\n    \:year 2014\\n    \:month 6\\n    \:day 1\\n    }\\n   \:end-date nil\\n   \:interval \\"w\\"\\n   \:nf 2\\n   \:iter 10})"]
eclipse.preferences.version=1
